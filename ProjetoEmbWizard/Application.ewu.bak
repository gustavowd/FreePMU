$version 6.60

// This is the root component of the entire GUI application.
$rect <20,20,220,60>
class Aplic : Core::Root
{
  $rect <0,330,200,370>
  inherited property Bounds = <0,0,480,270>;

  $rect <0,290,140,330>
  inherited method Init()
  {
  }

  $rect <0,410,200,450>
  $output true
  var int32 nrTela = 1;

  // This animation effect drives the transition between two screens.
  $rect <0,370,200,410>
  object Effects::PointEffect Anima
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Value2 = <0,0>;
    preset Outlet = ^Janela.ScrollOffset;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,280>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,240,480,272>;
    preset Color = Flat::ColorOfBody;
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <0,240,480,270>;
    preset String = "Fasores";
    preset Font = Application::NumbersG;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,480,272>;
    preset OnBottomRight = onWipeRight;
    preset OnTopRight = onWipeRight;
    preset OnBottomLeft = onWipeLeft;
    preset OnTopLeft = onWipeLeft;
    preset OnRight = onWipeRight;
    preset OnLeft = onWipeLeft;
  }

  $rect <20,20,160,60>
  object Core::Outline Janela
  {
    preset Bounds = <0,0,480,242>;
  }

  $rect <20,20,160,60>
  object Application::Fasores TFasores
  {
    preset Bounds = <0,0,480,242>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::Freq TFreq
  {
    preset Bounds = <480,0,960,242>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::Mag TMag
  {
    preset Bounds = <960,0,1440,242>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::Fase TFase
  {
    preset Bounds = <1440,0,1920,242>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::FFT TFFT
  {
    preset Bounds = <1920,0,2400,242>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::PDC TVNC
  {
    preset Bounds = <2400,0,2880,242>;
    preset Embedded = true;
  }

  // This method is called when the user has performed a wipe left gesture. It starts \
  // a transition to the next screen.
  $rect <210,299,400,339>
  slot onWipeLeft
  {
    // Wait till the preceding screen transition is finished
    if ( Anima.Enabled )
      return;

    // Are more screens to see or is the current screen the last one (screen #3)?
    if ( TVNC.Bounds.x1 < Bounds.w )
      return;

    // Run the screen transition  as animation
    Anima.Value1  = Janela.ScrollOffset;
    Anima.Value2  = Janela.ScrollOffset - point( Bounds.w, 0 );
    Anima.Enabled = true;

    nrTela = nrTela + 1;

    if (nrTela > 6) { nrTela = 6; }

    switch (nrTela) {
      case 1:
        Title.String = "Fasores";
      case 2:
        Title.String = "Frequência";
      case 3:
        Title.String = "Magnitude";
      case 4:
        Title.String = "Fase";
      case 5:
        Title.String = "FFT";
      case 6:
        Title.String = "Servidor de Dados para PDC";
      default:;
    }
  }

  // This method is called when the user has performed a wipe right gesture. It starts \
  // a transition to the preceding screen.
  $rect <210,340,400,380>
  slot onWipeRight
  {
    // Wait till the preceding screen transition is finished
    if ( Anima.Enabled )
      return;

    // Are more screens to see or is the current screen the last one (screen #1)?
    if ( TFasores.Bounds.x1 >= 0 )
      return;

    // Run the screen transition  as animation
    Anima.Value1  = Janela.ScrollOffset;
    Anima.Value2  = Janela.ScrollOffset + point( Bounds.w, 0 );
    Anima.Enabled = true;

    nrTela = nrTela - 1;

    if (nrTela < 0) { nrTela = 0; }

    switch (nrTela) {
      case 1:
        Title.String = "Fasores";
      case 2:
        Title.String = "Frequência";
      case 3:
        Title.String = "Magnitude";
      case 4:
        Title.String = "Fase";
      case 5:
        Title.String = "FFT";
      case 6:
        Title.String = "Servidor de Dados para PDC";
      default:;
    }
  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder keyLastLocked 1
  $reorder keyLastCharCode 1
  $reorder keyLastCode 1
  $reorder keyLastTarget 1
  $reorder hasRootFocus 1
  $reorder updateLock 1
  $reorder animationLock 1
  $reorder modalGroups 1
  $reorder currentEventTimestamp 1
  $reorder createDragEvent 1
  $reorder createCursorEvent 1
  $reorder createCursorGrabEvent 1
  $reorder cursorHoldTimerProc 1
  $reorder cursorHoldTimer 1
  $reorder cursorSequelCounter 1
}

$rect <30,650,230,690>
$output false
resource Resources::Bitmap flecha
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\arrow_a.bmp;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <30,610,230,650>
$output false
resource Resources::Bitmap grid
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\grid_a.bmp;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <30,530,230,570>
$output false
resource Resources::Font NumbersM
{
  attr fontname FontName = Unispace;
  attr fontheight Height = 18;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,490,230,530>
$output false
resource Resources::Font NumbersP
{
  attr fontname FontName = Unispace;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,570,230,610>
$output false
resource Resources::Font NumbersG
{
  attr fontname FontName = Unispace;
  attr fontheight Height = 22;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,60,230,100>
$output false
class Fasores : Core::Group
{
  $rect <10,430,210,470>
  inherited property Bounds = <0,0,480,242>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,310,150,350>
  inherited method Init()
  {
    fasor_R.RotateAndScale( centro, 0, amplitude, 1);
    fasor_S.RotateAndScale( centro, 0, amplitude, 1);
    fasor_T.RotateAndScale( centro, 0, amplitude, 1);
    angulo = math_rand(0.0,90.0)+math_rand(-5.0,+5.0);
  }

  $rect <430,390,630,430>
  var float angulo = 0;

  $rect <430,350,630,390>
  var float amplitude = 1;

  $rect <430,310,630,350>
  var point centro = <135,120>;

  $rect <20,20,160,60>
  object Views::Image grid
  {
    preset Bounds = <25,10,245,230>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Application::grid;
  }

  $rect <20,20,160,60>
  object Views::Text label0
  {
    preset Bounds = <230,110,280,130>;
    preset AutoSize = false;
    preset String = 0;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label180
  {
    preset Bounds = <-12,110,38,130>;
    preset AutoSize = false;
    preset String = 180;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label90
  {
    preset Bounds = <110,-5,160,15>;
    preset AutoSize = false;
    preset String = 90;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label270
  {
    preset Bounds = <110,225,160,245>;
    preset AutoSize = false;
    preset String = -90;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label300
  {
    preset Bounds = <192,213,210,225>;
    preset AutoSize = true;
    preset String = -60;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label240
  {
    preset Bounds = <60,213,78,225>;
    preset AutoSize = true;
    preset String = -120;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label210
  {
    preset Bounds = <19,171,37,183>;
    preset AutoSize = true;
    preset String = -150;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label120
  {
    preset Bounds = <62,13,80,25>;
    preset AutoSize = true;
    preset String = 120;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label60
  {
    preset Bounds = <192,13,204,25>;
    preset AutoSize = true;
    preset String = 60;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label330
  {
    preset Bounds = <234,171,252,183>;
    preset AutoSize = true;
    preset String = -30;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label30
  {
    preset Bounds = <236,58,248,70>;
    preset AutoSize = true;
    preset String = 30;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text label150
  {
    preset Bounds = <18,58,36,70>;
    preset AutoSize = true;
    preset String = 150;
    preset Font = OldResources::FontArial12;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text labelMag
  {
    preset Bounds = <282,16,386,32>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Magnitude [V]";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text labelAng
  {
    preset Bounds = <401,16,465,32>;
    preset AutoSize = true;
    preset String = "Fase [°]";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text fTverm_mag
  {
    preset Bounds = <376,95,385,113>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Views::Text fTverm_ang
  {
    preset Bounds = <455,95,464,113>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Views::Text fSamarelo_mag
  {
    preset Bounds = <376,70,385,88>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Views::Text fSamarelo_ang
  {
    preset Bounds = <455,70,464,88>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Views::Text fRverde_mag
  {
    preset Bounds = <376,45,385,63>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_R;
  }

  $rect <20,20,160,60>
  object Views::Text fRverde_ang
  {
    preset Bounds = <455,45,464,63>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersM;
    preset Color = Application::cor_R;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <475,37>;
    preset Point1 = <272,37>;
    preset Color = #FFFFFFFF;
  }

  $rect <220,350,420,390>
  object Core::Timer Timer
  {
    preset OnTrigger = roda;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::WarpImage fasor_T
  {
    preset Point4 = <115,160>;
    preset Point3 = <240,160>;
    preset Point2 = <240,152>;
    preset Point1 = <115,152>;
    preset SourceAnchor = <0,4>;
    preset Color1 = #FFFFFFFF;
    preset Color = Application::cor_T;
    preset Bitmap = Application::flecha;
  }

  $rect <20,20,160,60>
  object Views::WarpImage fasor_S
  {
    preset Point4 = <115,148>;
    preset Point3 = <240,148>;
    preset Point2 = <240,140>;
    preset Point1 = <115,140>;
    preset SourceAnchor = <0,4>;
    preset Color1 = #FFFFFFFF;
    preset Color = Application::cor_S;
    preset Bitmap = Application::flecha;
  }

  $rect <20,20,160,60>
  object Views::WarpImage fasor_R
  {
    preset Point4 = <135,123>;
    preset Point3 = <245,123>;
    preset Point2 = <245,115>;
    preset Point1 = <135,115>;
    preset SourceAnchor = <0,4>;
    preset Color1 = #FFFFFFFF;
    preset Color = Application::cor_R;
    preset Bitmap = Application::flecha;
  }

  $rect <220,390,420,430>
  slot roda
  {
    fasor_R.RotateAndScale( centro, device.getFaseR(), amplitude, 1);
    fRverde_mag.String = float2String(device.getMagR());
    fRverde_ang.String = float2String(device.getFaseR());

    fasor_S.RotateAndScale( centro, device.getFaseS(), amplitude, 1);
    fSamarelo_mag.String = float2String(device.getMagS());
    fSamarelo_ang.String = float2String(device.getFaseS());

    fasor_T.RotateAndScale( centro, device.getFaseT(), amplitude, 1);
    fTverm_mag.String = float2String(device.getMagT());
    fTverm_ang.String = float2String(device.getFaseT());
  }

  $rect <520,10,720,50>
  method string float2String( arg float arg1 )
  {
    var string valor = "";
    var string valor2;
    var int32 inteiro;
    var float dec;

    if (arg1 < 0.0) {
      valor = "-";
      inteiro = (int32)(-arg1);
      dec = (arg1 + (float)inteiro)*-100.0;
    } else {
      inteiro = (int32)arg1;
      dec = (arg1 - (float)inteiro)*100.0;
    }

    valor = valor + string(inteiro);
    valor2 = string((int32)dec, 2);
    return (valor + "," + valor2);
  }

  // ATENÇÃO:
  // O método "float2String" existe devido ao casting nativo de float para string \
  // do Embedded Wizard não exibir quando estiver rodando na MCU real, apesar de \
  // mostrar corretamente no prototipador do EW Studio.
  // 
  // Esta versão retorna uma string a partir de um float com 2 casas após a vírgula \
  // e separador de milhar.
  note legend Note
  {
    attr Bounds = <520,50,910,220>;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <520,220,720,260>
  var Application::Classe device = Application::Autoobjeto;
}

$rect <30,100,230,140>
$output false
class Freq : Core::Group
{
  $rect <0,250,200,290>
  inherited property Bounds = <0,0,480,242>;

  $rect <0,330,200,370>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,290,200,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <500,180,640,220>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];

    atualizaX();
    atualizaY();

    config.Sair.OnAction = sairConfig;
    config.SupMenos.OnAction = trocaEscala;
    config.SupMais.OnAction = trocaEscala;
    config.InfMenos.OnAction = trocaEscala;
    config.InfMais.OnAction = trocaEscala;
    config.SupSignMais.OnAction = trocaEscala;
    config.SupSignMenos.OnAction = trocaEscala;

    signal trocaEscala;
  }

  $rect <20,20,160,60>
  object Views::Text val_fr_0
  {
    preset Bounds = <400,180,480,200>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "58,0 Hz";
    preset Font = Application::NumbersP;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text val_fr_1
  {
    preset Bounds = <400,120,480,140>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "60,0 Hz";
    preset Font = Application::NumbersP;
    preset Color = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Text val_fr_2
  {
    preset Bounds = <400,60,480,80>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "62,0 Hz";
    preset Font = Application::NumbersP;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_0
  {
    preset Bounds = <370,220,430,240>;
    preset String = "0s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_1
  {
    preset Bounds = <275,220,335,240>;
    preset String = "45s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_2
  {
    preset Bounds = <180,220,240,240>;
    preset String = "90s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_3
  {
    preset Bounds = <85,220,145,240>;
    preset String = "135s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_4
  {
    preset Bounds = <2,220,62,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "180s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text labelFreq
  {
    preset Bounds = <20,0,140,40>;
    preset AutoSize = false;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Frequência:";
    preset Font = Application::NumbersG;
  }

  $rect <20,20,160,60>
  object Views::Text val_freq
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <140,0,270,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = 0;
    preset Font = Application::NumbersG;
  }

  $rect <210,350,390,390>
  object Core::Timer intervalo
  {
    preset OnTrigger = plotar;
    preset Period = 500;
    preset Enabled = true;
  }

  $rect <210,310,390,350>
  slot plotar
  {
    var float v = device.getFreq();

    val_freq.String = float2String(v, 3) + " Hz";
    v = v - valorMeio;

    grafico.AddData(-v);
  }

  $rect <500,0,700,40>
  method string float2String( arg float numero, arg int32 casas )
  {
    var string valor = "";
    var string valor2;
    var int32 inteiro;
    var float dec;

    if (numero < 0.0) {
      valor = "-";
      inteiro = (int32)(-numero);
      dec = (numero + (float)inteiro)*(-1.0*math_pow(10.0,float(casas)));
    } else {
      inteiro = (int32)numero;
      dec = (numero - (float)inteiro)*math_pow(10.0,float(casas));
    }

    dec = math_round(dec);
    if (dec >= math_pow(10.0,float(casas))) dec = dec - 1.0;

    valor = valor + string(inteiro);
    valor2 = string((int32)dec, casas);

    return (valor + "," + valor2);
  }

  $rect <210,270,410,310>
  var float valorMeio = 50.0;

  // ATENÇÃO:
  // O método "float2String" existe devido ao casting nativo de float para string \
  // do Embedded Wizard não exibir quando estiver rodando na MCU real, apesar de \
  // mostrar corretamente no prototipador do EW Studio.
  // 
  // Esta versão retorna uma string a partir de um float com 3 casas após a vírgula.
  note legend Note
  {
    attr Bounds = <500,40,1030,170>;
  }

  // Os rótulos horizontais e verticais têm seus valores calculos automaticamente \
  // quando esta classe é instanciada, pelo método de inicialização Init().
  note legend Note1
  {
    attr Bounds = <780,180,1170,260>;
  }

  note arrow Note5
  {
    attr Point1 = <300,390>;
    attr Point2 = <300,450>;
  }

  // O intervalo de atualização dos dados do gráfico é dado pelo período deste timer.
  note legend Note6
  {
    attr Bounds = <210,450,390,570>;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <700,0,900,40>
  var Application::Classe device = Application::Autoobjeto;

  $rect <20,20,160,60>
  object Application::ModIconButton IconButton
  {
    preset Bounds = <430,10,470,50>;
    preset OnAction = mostraConfig;
    preset Icon = Resources::SymbolIconsMedium;
    preset IconIndex = 7;
  }

  $rect <0,380,200,420>
  slot mostraConfig
  {
    if (fadeOut.Enabled)
      return;

    if (sender == fadeIn)
      fadeIn.Enabled = false;
      
    if (sender == IconButton)
      fadeIn.Enabled = true;
  }

  $rect <0,420,200,460>
  slot sairConfig
  {
    if (fadeIn.Enabled)
      return;

    if (sender == fadeOut)
      fadeOut.Enabled = false;

    if (sender == config.Sair)
      fadeOut.Enabled = true;
  }

  $rect <0,460,200,500>
  slot trocaEscala
  {
    if (sender == config.SupMenos) {
      if (unitsIdx > 0) {
        unitsIdx = unitsIdx - 1;
        atualizaY();
      }
    } else if (sender == config.SupMais) {
      if (unitsIdx < unitsV.size-1) {
        unitsIdx = unitsIdx + 1;
        atualizaY();
      }
    } else if (sender == config.InfMenos) {
      if (freqIdx > 0) {
        freqIdx = freqIdx - 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    } else if (sender == config.InfMais) {
      if (freqIdx < freqV.size-1) {
        freqIdx = freqIdx + 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    } else if (sender == config.SupSignMais) {
      if (valorMeio < 60.0) {
        valorMeio = valorMeio + 5.0;
        atualizaY();
        grafico.ClearPath();
      }
    } else if (sender == config.SupSignMenos) {
      if (valorMeio > 50.0) {
        valorMeio = valorMeio - 5.0;
        atualizaY();
        grafico.ClearPath();
      }
    }

    if (unitsIdx == 0) {
      config.SupMenos.Enabled = false;
      config.SupMais.Enabled = true;
    } else if (unitsIdx == unitsV.size-1) {
      config.SupMenos.Enabled = true;
      config.SupMais.Enabled = false;
    } else {
      config.SupMenos.Enabled = true;
      config.SupMais.Enabled = true;
    }

    if (freqIdx == 0) {
      config.InfMenos.Enabled = false;
      config.InfMais.Enabled = true;
    } else if (freqIdx == freqV.size-1) {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = false;
    } else {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = true;
    }

    if (valorMeio >= 60.0) {
      config.SupSignMais.Enabled = false;
      config.SupSignMenos.Enabled = true;
    } else if (valorMeio <= 50.0) {
      config.SupSignMais.Enabled = true;
      config.SupSignMenos.Enabled = false;
    } else {
      config.SupSignMais.Enabled = true;
      config.SupSignMenos.Enabled = true;
    }

    config.SupVal.String = string(float2String(valorMeio-unitsV[unitsIdx],3)) + " - " + string(float2String(valorMeio+unitsV[unitsIdx],3)) + " Hz";
    config.InfVal.String = string(freqV[freqIdx]) + " Hz (" + string(int32(1000/freqV[freqIdx])) + " ms)";
  }

  // Atualiza os rótulos do eixo vertical do gráfico e a proporção de plotagem.
  $rect <500,220,640,260>
  method void atualizaY()
  {
    /* Define a razão de pixels por unidade dos gráfico para ser condizente com a propriedade de deltaUnidades.
       ATENÇÃO: Essa propriedade é um int e tem que ser maior que 1. Caso a divisão dê um número menor, ele será 1.  */
    grafico.VerticalRatio = float(grafico.Bounds.h/3) / unitsV[unitsIdx];

    /* Cálculo dos rótulos dos valores de frequência, com base na proporção de pixels por unidade de medida  do
       eixo y (PixelPerUnit.y) do objeto Charts::Graph "grafico". */
    val_fr_1.String = float2String(valorMeio, 3) + " Hz";                        
    val_fr_0.String = float2String(valorMeio - unitsV[unitsIdx], 3) + " Hz";
    val_fr_2.String = float2String(valorMeio + unitsV[unitsIdx], 3) + " Hz";
  }

  // Atualiza os rótulos do eixo X no gráfico.
  $rect <640,180,780,220>
  method void atualizaX()
  {
    /* Cálculo dos rótulos de tempo, com base no período do objeto Core::Timer "intervalo"
       e a proporção de pixels por unidade de medida do eixo x (PixelPerUnit.x) do objeto Charts::Graph "grafico".    
       A distância entre cada divisão vertical é de 90 pixels, o que explica os valores 90, 180, 270 e 360.                        */
                                                                                                                                                              
    val_t_1.String = float2String(float(grafico.Bounds.w/4)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_2.String = float2String(float(grafico.Bounds.w/2)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_3.String = float2String(float(3*grafico.Bounds.w/4) * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_4.String = float2String(float(grafico.Bounds.w)     * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
  }

  $rect <410,270,610,310>
  array int32 freqV[ 7 ] =
  (
    Default[0] = 1;
    Default[1] = 2;
    Default[2] = 5;
    Default[3] = 10;
    Default[4] = 20;
    Default[5] = 25;
    Default[6] = 30;
  );

  $rect <410,310,610,350>
  var int32 freqIdx = 5;

  $rect <410,350,610,390>
  array float unitsV[ 8 ] =
  (
    Default[0] = 0.005;
    Default[1] = 0.01;
    Default[2] = 0.1;
    Default[3] = 0.2;
    Default[4] = 0.5;
    Default[5] = 1.0;
    Default[6] = 2.0;
    Default[7] = 5.0;
  );

  $rect <410,390,610,430>
  var int32 unitsIdx = 3;

  $rect <0,510,200,550>
  object Effects::Int32Effect fadeIn
  {
    preset OnFinished = mostraConfig;
    preset Oscillations = 0;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Outlet = ^config.Opacity;
  }

  $rect <0,550,200,590>
  object Effects::Int32Effect fadeOut
  {
    preset OnFinished = sairConfig;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^config.Opacity;
  }

  $rect <20,20,160,60>
  object Application::PlotterGraph grafico
  {
    preset Bounds = <20,40,400,220>;
    preset StrokeColor = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Application::ConfigScreen config
  {
    preset Bounds = <20,40,400,220>;
    preset Opacity = 0;
  }
}

$rect <30,180,230,220>
$output false
class Mag : Core::Group
{
  $rect <0,250,200,290>
  inherited property Bounds = <0,0,480,242>;

  $rect <0,330,200,370>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,290,200,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <900,0,1040,40>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];

    atualizaX();
    atualizaY();

    config.Sair.OnAction = sairConfig;
    config.SupMenos.OnAction = trocaEscala;
    config.SupMais.OnAction = trocaEscala;
    config.InfMenos.OnAction = trocaEscala;
    config.InfMais.OnAction = trocaEscala;

    config.SupSignMais.Visible = false;
    config.SupSignMenos.Visible = false;

    signal trocaEscala;
  }

  $rect <200,250,380,290>
  object Core::Timer intervalo
  {
    preset OnTrigger = plotar;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_inf
  {
    preset Bounds = <410,180,480,200>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "110 V";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_meio
  {
    preset Bounds = <410,120,480,140>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "120 V";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_sup
  {
    preset Bounds = <410,60,480,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "130 V";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_ini
  {
    preset Bounds = <370,220,430,240>;
    preset String = "0s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_1
  {
    preset Bounds = <275,220,335,240>;
    preset String = "45s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_2
  {
    preset Bounds = <180,220,240,240>;
    preset String = "90s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_3
  {
    preset Bounds = <85,220,145,240>;
    preset String = "135s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_4
  {
    preset Bounds = <4,220,64,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "180s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_T
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <350,0,420,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Views::Text val_S
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <270,0,340,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Views::Text val_R
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <190,0,260,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_R;
  }

  $rect <20,20,160,60>
  object Views::Text labelUnidades
  {
    preset Bounds = <20,0,188,40>;
    preset AutoSize = false;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Magnitudes (V):";
    preset Font = Application::NumbersG;
  }

  $rect <200,290,380,330>
  slot plotar
  {
    var float valor_R;
    var float valor_S;
    var float valor_T;

    valor_R = device.getMagR();
    valor_S = device.getMagS();
    valor_T = device.getMagT();

    val_R.String = float2String(valor_R, 1);
    val_S.String = float2String(valor_S, 1);
    val_T.String = float2String(valor_T, 1);

    valor_R = valor_R - valorMeio;
    valor_S = valor_S - valorMeio;
    valor_T = valor_T - valorMeio;

    grafico.AddData( -valor_R, -valor_S, -valor_T );
  }

  $rect <500,0,700,40>
  method string float2String( arg float numero, arg int32 casas )
  {
    var string valor = "";
    var string valor2;
    var int32 inteiro;
    var float dec;

    if (numero < 0.0) {
      valor = "-";
      inteiro = (int32)(-numero);
      dec = (numero + (float)inteiro)*(-1.0*math_pow(10.0,float(casas)));
    } else {
      inteiro = (int32)numero;
      dec = (numero - (float)inteiro)*math_pow(10.0,float(casas));
    }

    dec = math_round(dec);
    if (dec >= math_pow(10.0,float(casas))) dec = dec - 1.0;

    valor = valor + string(inteiro);
    valor2 = string((int32)dec, casas);

    return (valor + "," + valor2);
  }

  $rect <420,380,600,420>
  var float valorMeio = 120.0;

  // ATENÇÃO:
  // O método "float2String" existe devido ao casting nativo de float para string \
  // do Embedded Wizard não exibir quando estiver rodando na MCU real, apesar de \
  // mostrar corretamente no prototipador do EW Studio.
  // 
  // Esta versão retorna uma string a partir de um float com 3 casas após a vírgula.
  note legend Note
  {
    attr Bounds = <500,40,890,210>;
  }

  // Os rótulos horizontais e verticais têm seus valores calculos automaticamente \
  // quando esta classe é instanciada, pelo método de inicialização Init().
  note legend Note1
  {
    attr Bounds = <890,80,1140,210>;
  }

  // O intervalo de atualização dos dados do gráfico é dado pelo período deste timer.
  note legend Note6
  {
    attr Bounds = <530,230,710,350>;
  }

  note arrow Note5
  {
    attr Point1 = <380,270>;
    attr Point2 = <530,270>;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <700,0,900,40>
  var Application::Classe device = Application::Autoobjeto;

  $rect <0,380,200,420>
  slot mostraConfig
  {
    if (fadeOut.Enabled)
      return;

    if (sender == fadeIn)
      fadeIn.Enabled = false;
      
    if (sender == IconButton)
      fadeIn.Enabled = true;
  }

  $rect <0,420,200,460>
  slot sairConfig
  {
    if (fadeIn.Enabled)
      return;

    if (sender == fadeOut)
      fadeOut.Enabled = false;

    if (sender == config.Sair)
      fadeOut.Enabled = true;
  }

  $rect <0,460,200,500>
  slot trocaEscala
  {
    if (sender == config.SupMenos) {
      if (unitsIdx > 0) {
        unitsIdx = unitsIdx - 1;
        atualizaY();
      }
    } else if (sender == config.SupMais) {
      if (unitsIdx < unitsV.size-1) {
        unitsIdx = unitsIdx + 1;
        atualizaY();
      }
    } else if (sender == config.InfMenos) {
      if (freqIdx > 0) {
        freqIdx = freqIdx - 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    } else if (sender == config.InfMais) {
      if (freqIdx < freqV.size-1) {
        freqIdx = freqIdx + 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    }

    if (unitsIdx == 0) {
      config.SupMenos.Enabled = false;
      config.SupMais.Enabled = true;
    } else if (unitsIdx == unitsV.size-1) {
      config.SupMenos.Enabled = true;
      config.SupMais.Enabled = false;
    } else {
      config.SupMenos.Enabled = true;
      config.SupMais.Enabled = true;
    }

    if (freqIdx == 0) {
      config.InfMenos.Enabled = false;
      config.InfMais.Enabled = true;
    } else if (freqIdx == freqV.size-1) {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = false;
    } else {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = true;
    }

    config.SupVal.String = string(float2String(valorMeio-unitsV[unitsIdx],1)) + " - " + string(float2String(valorMeio+unitsV[unitsIdx],1)) + " V";
    config.InfVal.String = string(freqV[freqIdx]) + " Hz (" + string(int32(1000/freqV[freqIdx])) + " ms)";
  }

  $rect <210,380,410,420>
  array int32 freqV[ 6 ] =
  (
    Default[0] = 1;
    Default[1] = 2;
    Default[2] = 5;
    Default[3] = 10;
    Default[4] = 20;
    Default[5] = 30;
  );

  $rect <210,420,410,460>
  var int32 freqIdx = 3;

  $rect <210,460,410,500>
  array float unitsV[ 6 ] =
  (
    Default[0] = 1.0;
    Default[1] = 2.0;
    Default[2] = 5.0;
    Default[3] = 10.0;
    Default[4] = 15.0;
    Default[5] = 20.0;
  );

  $rect <210,500,410,540>
  var int32 unitsIdx = 0;

  $rect <0,510,200,550>
  object Effects::Int32Effect fadeIn
  {
    preset OnFinished = mostraConfig;
    preset Oscillations = 0;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Outlet = ^config.Opacity;
  }

  $rect <0,550,200,590>
  object Effects::Int32Effect fadeOut
  {
    preset OnFinished = sairConfig;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^config.Opacity;
  }

  // Atualiza os rótulos do eixo vertical do gráfico e a proporção de plotagem.
  $rect <1040,40,1180,80>
  method void atualizaY()
  {
    grafico.VerticalRatio = 60.0 / unitsV[unitsIdx];

    /* Cálculo dos rótulos dos valores de frequência, com base na proporção de pixels por unidade de medida  do
       eixo y (PixelPerUnit.y) do objeto Charts::Graph "grafico". A distância entre cada divisão horizontal é 
       de 60 pixels. */
    val_m_meio.String = float2String(valorMeio, 1) + " V";                        
    val_m_inf.String = float2String(valorMeio - unitsV[unitsIdx], 1) + " V";
    val_m_sup.String = float2String(valorMeio + unitsV[unitsIdx], 1) + " V";
  }

  // Atualiza os rótulos do eixo X no gráfico.
  $rect <1040,0,1180,40>
  method void atualizaX()
  {
    /* Cálculo dos rótulos de tempo, com base no período do objeto Core::Timer "intervalo"
       e a proporção de pixels por unidade de medida do eixo x (PixelPerUnit.x) do objeto Charts::Graph "grafico".    
       A distância entre cada divisão vertical é de 90 pixels, o que explica os valores 90, 180, 270 e 360. */
    val_t_1.String = float2String(float(grafico.Bounds.w/4)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_2.String = float2String(float(grafico.Bounds.w/2)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_3.String = float2String(float(3*grafico.Bounds.w/4) * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_4.String = float2String(float(grafico.Bounds.w)     * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
  }

  $rect <20,20,160,60>
  object Application::ModIconButton IconButton
  {
    preset Bounds = <430,10,470,50>;
    preset OnAction = mostraConfig;
    preset Icon = Resources::SymbolIconsMedium;
    preset IconIndex = 7;
  }

  $rect <20,20,160,60>
  object Application::PlotterTripleGraph grafico
  {
    preset Bounds = <20,40,400,220>;
    preset StrokeColorR = Application::cor_R;
    preset StrokeColorS = Application::cor_S;
    preset StrokeColorT = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Application::ConfigScreen config
  {
    preset Bounds = <20,40,400,220>;
    preset Opacity = 0;
  }
}

$rect <30,220,230,260>
$output false
class Fase : Core::Group
{
  $rect <0,250,200,290>
  inherited property Bounds = <0,0,480,242>;

  $rect <0,330,200,370>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,290,200,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <900,0,1040,40>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];

    atualizaX();

    setConfigScreen();

    signal trocaEscala;
  }

  $rect <200,250,380,290>
  object Core::Timer intervalo
  {
    preset OnTrigger = plotar;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text labelFaseInf
  {
    preset Bounds = <400,180,480,200>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "-120 °";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text labelFaseMeio
  {
    preset Bounds = <400,120,480,140>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "0 °";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text labelFaseSup
  {
    preset Bounds = <400,60,480,80>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "120 °";
    preset Font = Application::NumbersP;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_ini
  {
    preset Bounds = <370,220,430,240>;
    preset String = "0s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_1
  {
    preset Bounds = <275,220,335,240>;
    preset String = "45s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_2
  {
    preset Bounds = <180,220,240,240>;
    preset String = "90s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_3
  {
    preset Bounds = <85,220,145,240>;
    preset String = "135s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_t_4
  {
    preset Bounds = <0,220,60,240>;
    preset String = "180s";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_T
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <350,0,420,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Views::Text val_S
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <270,0,340,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Views::Text val_R
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <190,0,260,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "100,0";
    preset Font = Application::NumbersG;
    preset Color = Application::cor_R;
  }

  $rect <20,20,160,60>
  object Views::Text labelUni
  {
    preset Bounds = <20,0,188,40>;
    preset AutoSize = false;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Fases (°):";
    preset Font = Application::NumbersG;
  }

  $rect <200,290,380,330>
  slot plotar
  {
    var float valor_R;
    var float valor_S;
    var float valor_T;

    valor_R = device.getFaseR();
    valor_S = device.getFaseS();
    valor_T = device.getFaseT();

    val_R.String = float2String(valor_R, 1);
    val_S.String = float2String(valor_S, 1);
    val_T.String = float2String(valor_T, 1);

    grafico.AddData( -valor_R, -valor_S, -valor_T );
  }

  $rect <500,0,700,40>
  method string float2String( arg float numero, arg int32 casas )
  {
    var string valor = "";
    var string valor2;
    var int32 inteiro;
    var float dec;

    if (numero < 0.0) {
      valor = "-";
      inteiro = (int32)(-numero);
      dec = (numero + (float)inteiro)*(-1.0*math_pow(10.0,float(casas)));
    } else {
      inteiro = (int32)numero;
      dec = (numero - (float)inteiro)*math_pow(10.0,float(casas));
    }

    dec = math_round(dec);
    if (dec >= math_pow(10.0,float(casas))) dec = dec - 1.0;

    valor = valor + string(inteiro);
    valor2 = string((int32)dec, casas);

    return (valor + "," + valor2);
  }

  // ATENÇÃO:
  // O método "float2String" existe devido ao casting nativo de float para string \
  // do Embedded Wizard não exibir quando estiver rodando na MCU real, apesar de \
  // mostrar corretamente no prototipador do EW Studio.
  // 
  // Esta versão retorna uma string a partir de um float com 3 casas após a vírgula.
  note legend Note
  {
    attr Bounds = <500,40,890,210>;
  }

  // Os rótulos horizontais e verticais têm seus valores calculos automaticamente \
  // quando esta classe é instanciada, pelo método de inicialização Init().
  note legend Note1
  {
    attr Bounds = <890,40,1140,210>;
  }

  // O intervalo de atualização dos dados do gráfico é dado pelo período deste timer.
  note legend Note6
  {
    attr Bounds = <530,230,710,350>;
  }

  note arrow Note5
  {
    attr Point1 = <380,270>;
    attr Point2 = <530,270>;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <700,0,900,40>
  var Application::Classe device = Application::Autoobjeto;

  $rect <0,380,200,420>
  slot mostraConfig
  {
    if (fadeOut.Enabled)
      return;

    if (sender == fadeIn)
      fadeIn.Enabled = false;
      
    if (sender == IconButton)
      fadeIn.Enabled = true;
  }

  $rect <0,420,200,460>
  slot sairConfig
  {
    if (fadeIn.Enabled)
      return;

    if (sender == fadeOut)
      fadeOut.Enabled = false;

    if (sender == config.Sair)
      fadeOut.Enabled = true;
  }

  $rect <0,460,200,500>
  slot trocaEscala
  {
    if (sender == config.InfMenos) {
      if (freqIdx > 0) {
        freqIdx = freqIdx - 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    } else if (sender == config.InfMais) {
      if (freqIdx < freqV.size-1) {
        freqIdx = freqIdx + 1;
        intervalo.Period = 1000 / freqV[freqIdx];
        atualizaX();
        grafico.ClearPath();
      }
    }

    if (freqIdx == 0) {
      config.InfMenos.Enabled = false;
      config.InfMais.Enabled = true;
    } else if (freqIdx == freqV.size-1) {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = false;
    } else {
      config.InfMenos.Enabled = true;
      config.InfMais.Enabled = true;
    }

    config.InfVal.String = string(freqV[freqIdx]) + " Hz (" + string(int32(1000/freqV[freqIdx])) + " ms)";
  }

  $rect <210,380,410,420>
  array int32 freqV[ 6 ] =
  (
    Default[0] = 1;
    Default[1] = 2;
    Default[2] = 5;
    Default[3] = 10;
    Default[4] = 20;
    Default[5] = 30;
  );

  $rect <210,420,410,460>
  var int32 freqIdx = 3;

  $rect <0,510,200,550>
  object Effects::Int32Effect fadeIn
  {
    preset OnFinished = mostraConfig;
    preset Oscillations = 0;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Outlet = ^config.Opacity;
  }

  $rect <0,550,200,590>
  object Effects::Int32Effect fadeOut
  {
    preset OnFinished = sairConfig;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^config.Opacity;
  }

  $rect <200,330,400,370>
  method void setConfigScreen()
  {
    config.Sair.OnAction = sairConfig;
    config.SupMenos.OnAction = trocaEscala;
    config.SupMais.OnAction = trocaEscala;
    config.InfMenos.OnAction = trocaEscala;
    config.InfMais.OnAction = trocaEscala;

    config.labelSup.Visible = false;
    config.SupVal.Visible = false;
    config.SupMais.Visible = false;
    config.SupMenos.Visible = false;
    config.SupSignMais.Visible = false;
    config.SupSignMenos.Visible = false;
  }

  $rect <20,20,160,60>
  object Application::PlotterTripleGraph grafico
  {
    preset Bounds = <20,40,400,220>;
    preset VerticalRatio = 0.5;
    preset StrokeColorR = Application::cor_R;
    preset StrokeColorS = Application::cor_S;
    preset StrokeColorT = Application::cor_T;
  }

  $rect <20,20,160,60>
  object Application::ConfigScreen config
  {
    preset Bounds = <20,40,400,220>;
    preset Opacity = 0;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton IconButton
  {
    preset Bounds = <430,10,470,50>;
    preset OnAction = mostraConfig;
    preset Icon = Resources::SymbolIconsMedium;
    preset IconIndex = 7;
  }

  // Atualiza os rótulos do eixo X no gráfico.
  $rect <1040,0,1180,40>
  method void atualizaX()
  {
    /* Cálculo dos rótulos de tempo, com base no período do objeto Core::Timer "intervalo"
       e a proporção de pixels por unidade de medida do eixo x (PixelPerUnit.x) do objeto Charts::Graph "grafico".    
       A distância entre cada divisão vertical é de 90 pixels, o que explica os valores 90, 180, 270 e 360. */
    val_t_1.String = float2String(float(grafico.Bounds.w/4)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_2.String = float2String(float(grafico.Bounds.w/2)   * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_3.String = float2String(float(3*grafico.Bounds.w/4) * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
    val_t_4.String = float2String(float(grafico.Bounds.w)     * (float(intervalo.Period)/1000.0) / 2.0, 1 ) + "s";
  }
}

$rect <30,260,230,300>
class FFT : Core::Group
{
  $rect <10,310,210,350>
  inherited property Bounds = <0,0,480,242>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,270,150,310>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <500,0,700,40>
  var Application::Classe device = Application::Autoobjeto;

  $rect <20,20,160,60>
  object Views::Line linha_h_10
  {
    preset Point2 = <80,220>;
    preset Point1 = <80,20>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_h_20
  {
    preset Point2 = <140,220>;
    preset Point1 = <140,20>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_h_30
  {
    preset Point2 = <200,220>;
    preset Point1 = <200,20>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_h_40
  {
    preset Point2 = <260,220>;
    preset Point1 = <260,20>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_m_25
  {
    preset Point2 = <320,170>;
    preset Point1 = <20,170>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_m_50
  {
    preset Point2 = <320,120>;
    preset Point1 = <20,120>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Line linha_m_75
  {
    preset Point2 = <320,70>;
    preset Point1 = <20,70>;
    preset Width = 1;
    preset Color = #777777FF;
  }

  $rect <20,20,160,60>
  object Views::Text val_h_10
  {
    preset Bounds = <60,220,100,240>;
    preset String = "10";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_h_20
  {
    preset Bounds = <120,220,160,240>;
    preset String = "20";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_h_30
  {
    preset Bounds = <180,220,220,240>;
    preset String = "30";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_h_40
  {
    preset Bounds = <240,220,280,240>;
    preset String = "40";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_25
  {
    preset Bounds = <330,160,370,180>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0,25";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_50
  {
    preset Bounds = <330,110,370,130>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0,5";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Views::Text val_m_75
  {
    preset Bounds = <330,60,370,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0,75";
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  object Charts::Graph graf_FFT
  {
    preset Bounds = <20,20,320,220>;
    preset Opacity = 255;
    preset Coordinates;
    preset LineColor = Application::cor_R;
    preset DotColor = #FF0000FF;
    preset DotWidth = 0;
    preset CoordOrigin = <0,200>;
    preset PixelPerUnit = <6,200>;
    preset BackColor = #5B562700;
    preset HorzGridColor = #0C0E6E00;
    preset VertGridColor = #0C0E6E00;
  }

  $rect <20,20,160,60>
  object Views::Border borda
  {
    preset Bounds = <20,20,320,220>;
    preset Color = #FFFFFFFF;
  }

  $rect <260,270,460,310>
  object Core::Timer intervalo
  {
    preset OnTrigger = atualizaFFT;
    preset Enabled = true;
  }

  $rect <260,310,460,350>
  slot atualizaFFT
  {
    if (faseAtual == 0) {
      graf_FFT.Coordinates = device.getFFT_R();
    } else if (faseAtual == 1) {
      graf_FFT.Coordinates = device.getFFT_S();  
    } else if (faseAtual == 2) {
      graf_FFT.Coordinates = device.getFFT_T();
    }
  }

  $rect <20,20,160,60>
  object Application::ModifiedButton botao_R
  {
    preset Bounds = <370,40,470,85>;
    preset OnAction = acaoBotao;
    preset Caption = "Fase R";
    preset ItemColor = Flat::ColorOfTouch;
    preset ItemColorActive = Application::cor_R;
  }

  $rect <20,20,160,60>
  object Application::ModifiedButton botao_S
  {
    preset Bounds = <370,100,470,145>;
    preset OnAction = acaoBotao;
    preset Caption = "Fase S";
    preset ItemColor = Flat::ColorOfDisabled;
    preset ItemColorActive = Application::cor_S;
  }

  $rect <20,20,160,60>
  object Application::ModifiedButton botao_T
  {
    preset Bounds = <370,160,470,205>;
    preset OnAction = acaoBotao;
    preset Caption = "Fase T";
    preset ItemColor = Flat::ColorOfDisabled;
    preset ItemColorActive = Application::cor_T;
  }

  $rect <260,350,460,390>
  var int32 faseAtual = 0;

  $rect <260,390,460,430>
  slot acaoBotao
  {
    if (sender == botao_R) {
      if (faseAtual == 0) {     
        /*  Se entrar aqui, quer dizer que é o mesmo botão que foi pressionado.
            Não é necessário fazer nada. */
        return;  
      }
      /*  Caso contrário, tem que mudar a FFT mostrada no gráfico. Primeiro, o timer é parado.
          Então, as cores dos botões e do gráfico são alteradas e a FFT obtida. */
      intervalo.Enabled = false;
      faseAtual = 0;
      botao_R.ItemColor = Flat::ColorOfTouch;
      botao_S.ItemColor = Flat::ColorOfDisabled;
      botao_T.ItemColor = Flat::ColorOfDisabled;
      graf_FFT.LineColor = Application::cor_R;
      graf_FFT.Coordinates = device.getFFT_R();
    } else if (sender == botao_S) {
      if (faseAtual == 1) {
        // Idem caso outros botões
        return;
      }
      intervalo.Enabled = false;
      faseAtual = 1;
      botao_S.ItemColor = Flat::ColorOfTouch;
      botao_R.ItemColor = Flat::ColorOfDisabled;
      botao_T.ItemColor = Flat::ColorOfDisabled;
      graf_FFT.LineColor = Application::cor_S;
      graf_FFT.Coordinates = device.getFFT_S();
    } else if (sender == botao_T) {
      if (faseAtual == 2) {
        // Idem caso outros botões
        return;
      }
      intervalo.Enabled = false;
      faseAtual = 2;
      botao_T.ItemColor = Flat::ColorOfTouch;
      botao_S.ItemColor = Flat::ColorOfDisabled;
      botao_R.ItemColor = Flat::ColorOfDisabled;
      graf_FFT.LineColor = Application::cor_T;
      graf_FFT.Coordinates = device.getFFT_T();
    }

    //Reinicia o timer
    intervalo.Enabled = true;
  }

  // Para faseAtual:
  // 0 - Fase R; 1 - Fase S; 2 - Fase T.
  note legend Note
  {
    attr Bounds = <460,340,680,400>;
  }
}

$rect <30,300,230,340>
class PDC : Core::Group
{
  $rect <10,310,210,350>
  inherited property Bounds = <0,0,480,240>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  $output true
  object Views::Text Message
  {
    preset Bounds = <10,30,470,80>;
    preset String = "Sem Mensagens";
    preset Font = Application::NumbersG;
    preset Color = #FFFFFFFF;
  }

  $rect <500,40,730,80>
  object Core::SystemEventHandler LogMessageHandler
  {
    preset OnEvent = LogMessage;
    preset Event = Application::Autoobjeto.LogMessageEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <730,40,930,80>
  slot LogMessage
  {
    var Application::PDCMessage ctxRecebido = (Application::PDCMessage)LogMessageHandler.Context;

    Message.String = ctxRecebido.message;
  }

  $rect <20,20,160,60>
  $output true
  object Application::ModifiedButton BStart
  {
    preset Bounds = <100,180,220,210>;
    preset OnAction = startVNC;
    preset Caption = "Iniciar";
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <500,0,700,40>
  var Application::Classe device = Application::Autoobjeto;

  $rect <500,160,700,200>
  slot startVNC
  {
    sender; /* the method is called from the sender object */

    device.startVNC();
  }

  $rect <20,20,160,60>
  object Views::Text labelMsg
  {
    preset Bounds = <0,0,260,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Estado da Conexão:";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Text labelState
  {
    preset Bounds = <0,80,220,110>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Estado do Servidor:";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  $output true
  object Views::Text Status
  {
    preset Bounds = <10,110,470,160>;
    preset String = "Desconhecido";
    preset Font = Application::NumbersG;
    preset Color = #FFFFFFFF;
  }

  $rect <500,80,730,120>
  object Core::SystemEventHandler StatusChangedHandler
  {
    preset OnEvent = StatusChange;
    preset Event = Application::Autoobjeto.StatusChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <730,80,930,120>
  slot StatusChange
  {
    var Application::PDCStatus ctxRecebido = (Application::PDCStatus)StatusChangedHandler.Context;

    Status.String = ctxRecebido.Status;
  }

  $rect <20,20,160,60>
  $output true
  object Application::ModifiedButton BStop
  {
    preset Bounds = <260,180,380,210>;
    preset Enabled = false;
    preset OnAction = stopVNC;
    preset Caption = "Parar";
  }

  $rect <500,200,700,240>
  slot stopVNC
  {
    sender; /* the method is called from the sender object */

    device.stopVNC();
  }

  $rect <500,120,730,160>
  object Core::SystemEventHandler ButtonChangedHandler
  {
    preset OnEvent = ButtonStateChange;
    preset Event = Application::Autoobjeto.ButtonStateEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <730,120,930,160>
  slot ButtonStateChange
  {
    var Application::PDCButtonState recebido = (Application::PDCButtonState)ButtonChangedHandler.Context;

    BStart.Enabled = recebido.Iniciar;
    BStop.Enabled = recebido.Parar;
  }
}

// Action button widget with a flat design. The widget is used as a simple push button \
// with a text.
$rect <40,340,240,380>
$output false
class ModifiedButton : Core::Group
{
  $rect <0,90,180,130>
  inherited property Bounds = <0,0,120,30>;

  $rect <0,130,180,170>
  inherited method UpdateViewState()
  {
    /* colorize frame and text, depending on current state of the view */
    if ( aState.contains( Core::ViewState[ Enabled ]))
    {
      if ( TouchHandler.Down && TouchHandler.Inside )
        Frame.Color = ItemColorActive;
      else
        Frame.Color = ItemColor;
    }
    else
      Frame.Color = Flat::ColorOfDisabled;

  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <0,180,180,220>
  slot enterLeaveSlot
  {
    InvalidateViewState();
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <0,220,180,260>
  slot pressReleaseSlot
  {
    /* releasing the finger outside the button area is ignored */
    if ( !TouchHandler.Down && TouchHandler.Inside )
    {
      /* inform the connected slot method */
      idlesignal OnAction;
    }
  }

  // The property 'OnAction' can refer to a slot method, which will receive a signal \
  // as soon the user has pressed the button. Thereupon the method's logic will be \
  // executed.
  $rect <190,90,370,130>
  property slot OnAction = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,30>;
    preset Point3 = <120,30>;
    preset Point2 = <120,0>;
    preset Point1 = <0,0>;
    preset OnLeave = enterLeaveSlot;
    preset OnEnter = enterLeaveSlot;
    preset OnRelease = pressReleaseSlot;
    preset OnPress = pressReleaseSlot;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,30>;
    preset Color = Flat::ColorOfTouch;
    preset Bitmap = Flat::FlatFrame;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,30>;
    preset String = "Button";
    preset Font = Application::NumbersG;
    preset Color = Flat::ColorOfBackground;
  }

  $rect <190,40,370,80>
  onset Caption
  {
    pure Caption = value;
    CaptionText.String  = value;
  }

  // The property 'Caption' stores the text to display within the item.
  $rect <190,0,370,40>
  property string Caption = "Button";

  // The class 'ActionButton' implements a simple push button to start a certain \
  // action.
  // The button contains a text item that can be set with the property 'Caption'.
  // Each time the user has pressed the button a signal is sent to the slot method \
  // 'OnAction'.
  // The colors of the widget can be changed by using the properties 'ItemColor', \
  // 'ItemColorActive' and 'TextColor'.
  note legend Note
  {
    attr Bounds = <10,280,700,380>;
  }

  // The property 'ItemColor' defines the color of the widgets touchable member (knob). \
  // The property is used to assign a color independent from the current theme color.
  $rect <370,0,550,40>
  property color ItemColor = Flat::ColorOfTouch;

  $rect <370,40,550,80>
  onset ItemColor
  {
    /* store the new value */
    pure ItemColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'TextColor' defines the color of the widgets text members. The \
  // property is used to assign a color independent from the current theme color.
  $rect <550,0,730,40>
  property color TextColor = Flat::ColorOfBackground;

  $rect <550,40,730,80>
  onset TextColor
  {
    /* store the new value */
    pure TextColor = value;

    /* ...and colorize the affected members of the widget */
    CaptionText.Color = value;

  }

  // The property 'ItemColorActive' defines the color of the widgets touchable member \
  // (knob) while it is touched by the user. The property is used to assign a color \
  // independent from the current theme color.
  $rect <370,90,550,130>
  property color ItemColorActive = Flat::ColorOfTheme;

  $rect <370,130,550,170>
  onset ItemColorActive
  {
    /* store the new value */
    pure ItemColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }
}

$rect <650,30,850,70>
inline Inline
{
  #include "vnc_app.h"

  extern float Freq_final;

  extern float Mag_R_final;
  extern float Mag_S_final;
  extern float Mag_T_final;

  extern float Fase_R_final;
  extern float Fase_S_final;
  extern float Fase_T_final;

  extern float FasesAC_mod_R[50];
  extern float FasesAC_mod_S[50];
  extern float FasesAC_mod_T[50];
}

$rect <650,100,860,140>
class Classe : Templates::DeviceClass
{
  // This object represents an individual system event.
  $rect <10,40,210,80>
  object Core::SystemEvent LogMessageEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,0,210,40>
  $output true
  method void LogMessageTrigger( arg string message )
  {
    var Application::PDCMessage contexto = new Application::PDCMessage;

    contexto.message = message;

    LogMessageEvent.Trigger( contexto, false );
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,180,210,220>
  $output true
  method native void startVNC()
  {
    VNC_SERVER_Start();
  }

  $rect <10,130,210,170>
  object Core::SystemEvent StatusChangedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,90,210,130>
  $output true
  method void StatusTrigger( arg string status )
  {
    var Application::PDCStatus contexto = new Application::PDCStatus;

    contexto.Status = status;

    StatusChangedEvent.Trigger( contexto, false );
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,220,210,260>
  $output true
  method native void stopVNC()
  {
    VNC_SERVER_Stop();
  }

  // Métodos contendo código em C que são chamados pela GUI para iniciar e parar \
  // a máquina de estados do servidor VNC.
  // Tais métodos devem ter a propriedade "native" habilitada.
  note legend Note
  {
    attr Bounds = <210,180,490,260>;
  }

  // System Event de quando a máquina de estados quer registrar uma mensagem. LogMessageTrigger \
  // é chamado fora da GUI, passando a mensagem como contexto e ativa o trigger de \
  // LogMessageEvent.
  // Com LogMessageEvent trigado, o handler dentro do módulo VNC recebe o contexto \
  // e mostra a mensagem na tela.
  note legend Note1
  {
    attr Bounds = <210,0,990,80>;
  }

  // System Event de quando a máquina de estados registra a troca de estado. Princípio \
  // de funcionamento análogo ao do registro de mensagem.
  note legend Note2
  {
    attr Bounds = <210,90,570,170>;
  }

  $rect <10,290,210,330>
  method float getFreq()
  {
    var float frequencia = 0.0;

    $if !$prototyper
    native (frequencia) {  
      frequencia = (XFloat)Freq_final;
    }
    $endif

    return frequencia;
  }

  $rect <10,330,210,370>
  method float getMagR()
  {
    var float magR = 0.0;

    $if !$prototyper
    native (magR) {
      magR = (XFloat)Mag_R_final;
    }
    $endif

    return magR;
  }

  $rect <10,410,210,450>
  method float getMagT()
  {
    var float magT = 0.0;

    $if !$prototyper
    native (magT) {
      magT = (XFloat)Mag_T_final;
    }
    $endif

    return magT;
  }

  $rect <10,370,210,410>
  method float getMagS()
  {
    var float magS = 0.0;

    $if !$prototyper
    native (magS) {
      magS = (XFloat)Mag_S_final;
    }
    $endif

    return magS;
  }

  $rect <210,330,410,370>
  method float getFaseR()
  {
    var float faseR = 0.0;

    $if !$prototyper
    native (faseR) {
      faseR = (XFloat)Fase_R_final;
    }
    $endif

    return 60.0+math_rand(-0.1,0.1);
  }

  $rect <210,410,410,450>
  method float getFaseT()
  {
    var float faseT = 0.0;

    $if !$prototyper
    native (faseT) {
      faseT = (XFloat)Fase_T_final;
    }
    $endif

    return faseT;
  }

  $rect <210,370,410,410>
  method float getFaseS()
  {
    var float faseS = 0.0;

    $if !$prototyper
    native (faseS) {
      faseS = (XFloat)Fase_S_final;
    }
    $endif

    return faseS;
  }

  $rect <10,480,210,520>
  method Charts::CoordList getFFT_R()
  {
    //Vetor que receberá os valores tratados do vetor de FFT
    array float           aFFT[50];
    var   int32           j;
    //Variável local de lista de coordenadas que será retornado no final do método
    var Charts::CoordList cordFFT = new Charts::CoordList;

    for (j = 0; j < aFFT.size; j = j + 1)
      aFFT[j] = 0.0;

    // Código nativo em C: tratamento do vetor de FFT para o vetor aFFT
    $if !$prototyper
    native (aFFT) {
      int i;
      
      for (i = 0; i < 50; i++) {
        aFFT[i] = FasesAC_mod_R[i]/422.4; //256*1.65
      }
    }
    $endif

    //Define o número máximo de itens no CoordList, limpa e adiciona os valores
    cordFFT.MaxNoOfItems = 50;
    cordFFT.ClearList();

    for (j = 0; j < 50; j = j + 1) {
      //cordFFT.AddCoord(j+1, -math_rand(0.2,0.3));  
      cordFFT.AddCoord(j+1, -aFFT[j]);
    }

    return cordFFT;
  }

  $rect <10,520,210,560>
  method Charts::CoordList getFFT_S()
  {
    //Vetor que receberá os valores tratados do vetor de FFT
    array float           aFFT[50];
    var   int32           j;
    //Variável local de lista de coordenadas que será retornado no final do método
    var Charts::CoordList cordFFT = new Charts::CoordList;

    for (j = 0; j < aFFT.size; j = j + 1)
      aFFT[j] = 0.0;

    // Código nativo em C: tratamento do vetor de FFT para o vetor aFFT
    $if !$prototyper
    native (aFFT) {
      int i;
      
      for (i = 0; i < 50; i++) {
        aFFT[i] = FasesAC_mod_S[i]/256.0;
      }
    }
    $endif

    //Define o número máximo de itens no CoordList, limpa e adiciona os valores
    cordFFT.MaxNoOfItems = 50;
    cordFFT.ClearList();

    for (j = 0; j < 50; j = j + 1) {
      //cordFFT.AddCoord(j+1, -math_rand(0.4,0.5));
      cordFFT.AddCoord(j+1, -aFFT[j]);
    }

    return cordFFT;
  }

  $rect <10,560,210,600>
  method Charts::CoordList getFFT_T()
  {
    //Vetor que receberá os valores tratados do vetor de FFT
    array float           aFFT[50];
    var   int32           j;
    //Variável local de lista de coordenadas que será retornado no final do método
    var Charts::CoordList cordFFT = new Charts::CoordList;

    for (j = 0; j < aFFT.size; j = j + 1)
      aFFT[j] = 0.0;

    // Código nativo em C: tratamento do vetor de FFT para o vetor aFFT
    $if !$prototyper
    native (aFFT) {
      int i;
      
      for (i = 0; i < 50; i++) {
        aFFT[i] = FasesAC_mod_T[i]/256.0;
      }
    }
    $endif

    //Define o número máximo de itens no CoordList, limpa e adiciona os valores
    cordFFT.MaxNoOfItems = 50;
    cordFFT.ClearList();

    for (j = 0; j < 50; j = j + 1) {
      //cordFFT.AddCoord(j+1, -math_rand(0.5,0.6));
      cordFFT.AddCoord(j+1, -aFFT[j]);
    }

    return cordFFT;
  }

  // Esses métodos retornam valores float que vêm direto do cálculo da PMU, para \
  // serem usados na interface.
  note legend Note3
  {
    attr Bounds = <420,290,720,450>;
  }

  // Estes métodos acessam as primeiras 50 posições de cada vetor de FFT para seu \
  // respectivo fasor, assim tendo as 50 harmônicas.
  // Esses valores são colocados em um objeto de lista de coordenadas (Charts::CoordList) \
  // para que este seja retornado pelo método e colocado diretamente no gráfico da \
  // FFT.
  note legend Note4
  {
    attr Bounds = <210,480,650,600>;
  }

  $rect <610,130,810,170>
  object Core::SystemEvent ButtonStateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <610,90,810,130>
  $output true
  method void ChangeBtnState( arg int32 IniState, arg int32 PararState )
  {
    var Application::PDCButtonState contexto_botao = new Application::PDCButtonState;

    if (IniState == 0) contexto_botao.Iniciar = false;
    else  contexto_botao.Iniciar = true;

    if (PararState == 0) contexto_botao.Parar = false;
    else  contexto_botao.Parar = true;

    ButtonStateEvent.Trigger(contexto_botao, false);
  }
}

$rect <660,140,880,180>
autoobject Application::Classe Autoobjeto;

$rect <650,190,850,230>
$output false
class PDCMessage
{
  $rect <10,10,210,50>
  property string message = 0;

  $rect <10,50,210,90>
  onset message
  {
    // The value doesn't change - nothing to do.
    if ( pure message == value )
      return;

    // Remember the property's new value.
    pure message = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <10,90,210,130>
  onget message
  {
    return pure message;
  }
}

$rect <650,230,850,270>
$output false
class PDCStatus
{
  $rect <10,10,210,50>
  property string Status = 0;

  $rect <10,50,210,90>
  onset Status
  {
    // The value doesn't change - nothing to do.
    if ( pure Status == value )
      return;

    // Remember the property's new value.
    pure Status = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <10,90,210,130>
  onget Status
  {
    return pure Status;
  }
}

$rect <450,490,650,530>
$output false
const color cor_R = #00FF00FF;

$rect <450,530,650,570>
$output false
const color cor_S = #FFFF00FF;

$rect <450,570,650,610>
$output false
const color cor_T = #FF0000FF;

// Classe das aplicações que são utilizadas. Os objetos Core::Group são módulos que \
// são instanciados no objeto Core::Root Aplic.
// 
// As variantes ao lado são as mesmas classes porém adaptadas para o STM32F769.
note legend Note
{
  attr Bounds = <430,60,630,300>;
}

// Inline com os includes necessários para executar código externo ao GUI.
note legend Note1
{
  attr Bounds = <850,30,1110,90>;
}

// Classe de dispositivo e autoobjeto necessários para a comunicação entre a GUI \
// e os códigos externos a ela.
note legend Note2
{
  attr Bounds = <880,100,1140,180>;
}

// Classes de contexo para uso com os system handlers dentro do DeviceClass Classe.
note legend Note3
{
  attr Bounds = <850,190,1070,270>;
}

// Define as cores de cada fasor (R, S e T). Elas podem ser trocadas e isto será \
// refletido em todo os recursos gráficos do projeto.
// 
// Padrões:
// R - #00FF00FF (verde)
// S - #FFFF00FF (amarelo)
// T - #FF0000FF (vermelho)
note legend Note4
{
  attr Bounds = <650,490,1000,660>;
}

$rect <220,20,420,60>
$variant STM32F769
vclass Aplic769 : Application::Aplic
{
  $rect <0,500,140,540>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  inherited object WipeTouchHandler
  {
    preset Bounds = <0,8,800,488>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,8,800,488>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <0,438,800,488>;
  }

  $rect <20,20,160,60>
  inherited object Title
  {
    preset Bounds = <30,438,770,480>;
  }

  $rect <20,20,160,60>
  inherited object Janela
  {
    preset Bounds = <0,8,800,438>;
  }

  $rect <20,20,160,60>
  inherited object TFasores
  {
    preset Bounds = <0,8,800,438>;
  }

  $rect <20,20,160,60>
  inherited object TFreq
  {
    preset Bounds = <800,8,1600,438>;
  }

  $rect <20,20,160,60>
  inherited object TMag
  {
    preset Bounds = <1600,8,2400,438>;
  }

  $rect <20,20,160,60>
  inherited object TFase
  {
    preset Bounds = <2400,8,3200,438>;
  }

  $rect <20,20,160,60>
  inherited object TFFT
  {
    preset Bounds = <3200,8,4000,438>;
  }

  $rect <20,20,160,60>
  inherited object TVNC
  {
    preset Bounds = <4000,8,4800,438>;
  }

  $reorder WipeTouchHandler 3
}

$rect <230,650,430,690>
$variant STM32F769
vresource flecha769 : Application::flecha
{
  attr AlphaName = .\arrow_a_769.bmp;
}

$rect <230,610,430,650>
$variant STM32F769
vresource grid769 : Application::grid
{
  attr AlphaName = .\grid_a_769.bmp;
}

$rect <230,530,430,570>
$variant STM32F769
vresource NumbersMh : Application::NumbersM
{
  attr Height = 32;
}

$rect <230,490,430,530>
$variant STM32F769
vresource NumbersPh : Application::NumbersP
{
  attr Height = 28;
}

$rect <230,570,430,610>
$variant STM32F769
vresource NumbersGh : Application::NumbersG
{
  attr Height = 37;
}

$rect <230,60,430,100>
$variant STM32F769
vclass Fasores769 : Application::Fasores
{
  $rect <10,450,150,490>
  inherited property Bounds = <0,0,800,430>;

  $rect <150,450,290,490>
  inherited var centro = <225,215>;

  $rect <20,20,160,60>
  inherited object grid
  {
    preset Bounds = <30,20,420,410>;
  }

  $rect <20,20,160,60>
  inherited object label0
  {
    preset Bounds = <410,205,460,225>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label180
  {
    preset Bounds = <-11,205,39,225>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label90
  {
    preset Bounds = <200,0,250,20>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label270
  {
    preset Bounds = <200,410,250,430>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label300
  {
    preset Bounds = <318,385,348,406>;
    preset AutoSize = true;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label240
  {
    preset Bounds = <99,383,129,404>;
    preset AutoSize = true;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label210
  {
    preset Bounds = <23,308,53,329>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label120
  {
    preset Bounds = <105,24,135,45>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label60
  {
    preset Bounds = <322,24,342,45>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label330
  {
    preset Bounds = <398,307,428,328>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label30
  {
    preset Bounds = <400,100,420,121>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object label150
  {
    preset Bounds = <20,100,50,121>;
    preset Font = Application::Arial21;
  }

  $rect <20,20,160,60>
  inherited object labelMag
  {
    preset Bounds = <450,20,632,48>;
  }

  $rect <20,20,160,60>
  inherited object labelAng
  {
    preset Bounds = <673,20,785,48>;
  }

  $rect <20,20,160,60>
  inherited object fTverm_mag
  {
    preset Bounds = <610,150,626,182>;
  }

  $rect <20,20,160,60>
  inherited object fTverm_ang
  {
    preset Bounds = <760,150,776,182>;
  }

  $rect <20,20,160,60>
  inherited object fSamarelo_mag
  {
    preset Bounds = <610,110,626,142>;
  }

  $rect <20,20,160,60>
  inherited object fSamarelo_ang
  {
    preset Bounds = <760,110,776,142>;
  }

  $rect <20,20,160,60>
  inherited object fRverde_mag
  {
    preset Bounds = <610,70,626,102>;
  }

  $rect <20,20,160,60>
  inherited object fRverde_ang
  {
    preset Bounds = <760,70,776,102>;
  }

  $rect <20,20,160,60>
  inherited object Line
  {
    preset Point2 = <790,60>;
    preset Point1 = <440,60>;
  }

  $rect <20,20,160,60>
  inherited object fasor_T
  {
    preset Point4 = <225,227>;
    preset Point3 = <420,227>;
    preset Point2 = <420,211>;
    preset Point1 = <225,211>;
    preset SourceAnchor = <2,7>;
  }

  $rect <20,20,160,60>
  inherited object fasor_S
  {
    preset Point4 = <225,227>;
    preset Point3 = <420,227>;
    preset Point2 = <420,211>;
    preset Point1 = <225,211>;
    preset SourceAnchor = <2,7>;
  }

  $rect <20,20,160,60>
  inherited object fasor_R
  {
    preset Point4 = <225,227>;
    preset Point3 = <420,227>;
    preset Point2 = <420,211>;
    preset Point1 = <225,211>;
    preset SourceAnchor = <2,7>;
  }
}

$rect <230,100,430,140>
$variant STM32F769
vclass Freq769 : Application::Freq
{
  $rect <10,440,150,480>
  inherited property Bounds = <0,0,800,430>;

  $rect <10,490,150,530>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];
    grafico.PathData.InitMatrix();
    atualizaX();
    atualizaY();

    config.Sair.OnAction = sairConfig;
    config.SupMenos.OnAction = trocaEscala;
    config.SupMais.OnAction = trocaEscala;
    config.InfMenos.OnAction = trocaEscala;
    config.InfMais.OnAction = trocaEscala;
    config.SupSignMais.OnAction = trocaEscala;
    config.SupSignMenos.OnAction = trocaEscala;

    signal trocaEscala;
  }

  $rect <20,20,160,60>
  inherited object val_fr_0
  {
    preset Bounds = <640,310,800,340>;
  }

  $rect <20,20,160,60>
  inherited object val_fr_1
  {
    preset Bounds = <640,200,800,230>;
  }

  $rect <20,20,160,60>
  inherited object val_fr_2
  {
    preset Bounds = <640,90,800,120>;
  }

  $rect <20,20,160,60>
  inherited object val_t_0
  {
    preset Bounds = <600,390,680,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_1
  {
    preset Bounds = <450,390,530,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_2
  {
    preset Bounds = <290,390,380,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_3
  {
    preset Bounds = <140,390,230,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_4
  {
    preset Bounds = <10,390,100,420>;
  }

  $rect <20,20,160,60>
  inherited object labelFreq
  {
    preset Bounds = <40,0,280,50>;
  }

  $rect <20,20,160,60>
  inherited object val_freq
  {
    preset Bounds = <280,0,530,50>;
  }

  $rect <20,20,160,60>
  inherited object IconButton
  {
    preset Bounds = <720,350,790,420>;
    preset Icon = Resources::SymbolIconsLarge;
    preset IconIndex = 7;
  }

  $rect <310,490,450,530>
  inherited method atualizaY()
  {
    /* Define a razão de pixels por unidade dos gráfico para ser condizente com a propriedade de deltaUnidades.
       ATENÇÃO: Essa propriedade é um int e tem que ser maior que 1. Caso a divisão dê um número menor, ele será 1.  */
    //grafico.PathData.InitMatrix();
    grafico.VerticalRatio = float(grafico.Bounds.h/3) / unitsV[unitsIdx];

    /* Cálculo dos rótulos dos valores de frequência, com base na proporção de pixels por unidade de medida  do
       eixo y (PixelPerUnit.y) do objeto Charts::Graph "grafico". */
    val_fr_1.String = float2String(valorMeio, 3) + " Hz";                        
    val_fr_0.String = float2String(valorMeio - unitsV[unitsIdx], 3) + " Hz";
    val_fr_2.String = float2String(valorMeio + unitsV[unitsIdx], 3) + " Hz";
  }

  $rect <160,490,300,530>
  inherited method atualizaX()
  {
    /* Cálculo dos rótulos de tempo, com base no período do objeto Core::Timer "intervalo"
       e a proporção de pixels por unidade de medida do eixo x (PixelPerUnit.x) do objeto Charts::Graph "grafico".    
       A distância entre cada divisão vertical é de 90 pixels, o que explica os valores 90, 180, 270 e 360.                        */
                                                                                                                                                          
    val_t_1.String = float2String(float(grafico.Bounds.w/4)   * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_2.String = float2String(float(grafico.Bounds.w/2)   * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_3.String = float2String(float(3*grafico.Bounds.w/4) * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_4.String = float2String(float(grafico.Bounds.w)     * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
  }

  $rect <20,20,160,60>
  inherited object grafico
  {
    preset Bounds = <40,50,640,380>;
    preset VerticalRatio = 1.1;
    preset StrokeWidth = 4.0;
  }

  $rect <20,20,160,60>
  inherited object config
  {
    preset Bounds = <40,50,640,380>;
  }
}

$rect <230,180,430,220>
$variant STM32F769
vclass Mag769 : Application::Mag
{
  $rect <10,440,150,480>
  inherited property Bounds = <0,0,800,430>;

  $rect <10,490,150,530>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];

    atualizaX();
    atualizaY();

    config.Sair.OnAction = sairConfig;
    config.SupMenos.OnAction = trocaEscala;
    config.SupMais.OnAction = trocaEscala;
    config.InfMenos.OnAction = trocaEscala;
    config.InfMais.OnAction = trocaEscala;

    signal trocaEscala;
  }

  $rect <20,20,160,60>
  inherited object val_m_inf
  {
    preset Bounds = <660,310,770,340>;
  }

  $rect <20,20,160,60>
  inherited object val_m_meio
  {
    preset Bounds = <660,200,770,230>;
  }

  $rect <20,20,160,60>
  inherited object val_m_sup
  {
    preset Bounds = <660,90,770,120>;
  }

  $rect <20,20,160,60>
  inherited object val_t_ini
  {
    preset Bounds = <600,390,680,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_1
  {
    preset Bounds = <450,390,530,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_2
  {
    preset Bounds = <300,390,380,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_3
  {
    preset Bounds = <150,390,230,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_4
  {
    preset Bounds = <10,390,90,420>;
  }

  $rect <20,20,160,60>
  inherited object val_T
  {
    preset Bounds = <590,5,720,45>;
  }

  $rect <20,20,160,60>
  inherited object val_S
  {
    preset Bounds = <460,5,590,45>;
  }

  $rect <20,20,160,60>
  inherited object val_R
  {
    preset Bounds = <330,5,460,45>;
  }

  $rect <20,20,160,60>
  inherited object labelUnidades
  {
    preset Bounds = <40,5,350,45>;
  }

  $rect <290,490,430,530>
  inherited method atualizaY()
  {
    grafico.PathDataR.InitMatrix();
    grafico.PathDataS.InitMatrix();
    grafico.PathDataT.InitMatrix();
    grafico.VerticalRatio = float(grafico.Bounds.h/3) / unitsV[unitsIdx];

    /* Cálculo dos rótulos dos valores de frequência, com base na proporção de pixels por unidade de medida  do
       eixo y (PixelPerUnit.y) do objeto Charts::Graph "grafico". A distância entre cada divisão horizontal é 
       de 60 pixels. */
    val_m_meio.String = float2String(valorMeio, 1) + " V";                        
    val_m_inf.String = float2String(valorMeio - unitsV[unitsIdx], 1) + " V";
    val_m_sup.String = float2String(valorMeio + unitsV[unitsIdx], 1) + " V";
  }

  $rect <150,490,290,530>
  inherited method atualizaX()
  {
    /* Cálculo dos rótulos de tempo, com base no período do objeto Core::Timer "intervalo"
       e a proporção de pixels por unidade de medida do eixo x (PixelPerUnit.x) do objeto Charts::Graph "grafico".    
       A distância entre cada divisão vertical é de 90 pixels, o que explica os valores 90, 180, 270 e 360. */
    val_t_1.String = float2String(float(grafico.Bounds.w/4)   * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_2.String = float2String(float(grafico.Bounds.w/2)   * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_3.String = float2String(float(3*grafico.Bounds.w/4) * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
    val_t_4.String = float2String(float(grafico.Bounds.w)     * (float(intervalo.Period)/1000.0) / 3.0, 1 ) + "s";
  }

  $rect <20,20,160,60>
  inherited object IconButton
  {
    preset Bounds = <720,350,790,420>;
    preset Icon = Resources::SymbolIconsLarge;
    preset IconIndex = 7;
  }

  $rect <20,20,160,60>
  inherited object grafico
  {
    preset Bounds = <40,50,640,380>;
    preset StrokeWidth = 4.0;
  }

  $rect <20,20,160,60>
  inherited object config
  {
    preset Bounds = <40,50,640,380>;
  }
}

$rect <230,220,430,260>
$variant STM32F769
vclass Fase769 : Application::Fase
{
  $rect <0,440,140,480>
  inherited property Bounds = <0,0,800,430>;

  $rect <0,480,140,520>
  inherited method Init()
  {
    intervalo.Period = 1000 / freqV[freqIdx];

    atualizaX();

    grafico.PathDataR.InitMatrix();
    grafico.PathDataS.InitMatrix();
    grafico.PathDataT.InitMatrix();
    grafico.VerticalRatio = float(grafico.Bounds.h/3)/120.0;

    setConfigScreen();

    signal trocaEscala;
  }

  $rect <20,20,160,60>
  inherited object labelFaseInf
  {
    preset Bounds = <660,310,770,340>;
  }

  $rect <20,20,160,60>
  inherited object labelFaseMeio
  {
    preset Bounds = <660,200,770,230>;
  }

  $rect <20,20,160,60>
  inherited object labelFaseSup
  {
    preset Bounds = <660,90,770,120>;
  }

  $rect <20,20,160,60>
  inherited object val_t_ini
  {
    preset Bounds = <600,390,680,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_1
  {
    preset Bounds = <450,390,530,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_2
  {
    preset Bounds = <300,390,380,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_3
  {
    preset Bounds = <150,390,230,420>;
  }

  $rect <20,20,160,60>
  inherited object val_t_4
  {
    preset Bounds = <0,390,80,420>;
  }

  $rect <20,20,160,60>
  inherited object val_T
  {
    preset Bounds = <590,5,720,45>;
  }

  $rect <20,20,160,60>
  inherited object val_S
  {
    preset Bounds = <460,5,590,45>;
  }

  $rect <20,20,160,60>
  inherited object val_R
  {
    preset Bounds = <330,5,460,45>;
  }

  $rect <20,20,160,60>
  inherited object labelUni
  {
    preset Bounds = <40,5,250,45>;
  }

  $rect <20,20,160,60>
  inherited object grafico
  {
    preset Bounds = <40,50,640,380>;
    preset StrokeWidth = 4.0;
  }

  $rect <20,20,160,60>
  inherited object config
  {
    preset Bounds = <40,50,640,380>;
  }

  $rect <20,20,160,60>
  inherited object IconButton
  {
    preset Bounds = <720,350,790,420>;
    preset Icon = Resources::SymbolIconsLarge;
    preset IconIndex = 7;
  }

  $rect <140,480,280,520>
  inherited method atualizaX()
  {
    // TO DO: Write your code here ... 
  }
}

$rect <230,260,430,300>
$variant STM32F769
vclass FFT769 : Application::FFT
{
  $rect <10,450,150,490>
  inherited property Bounds = <0,0,800,430>;

  $rect <20,20,160,60>
  inherited object linha_h_10
  {
    preset Point2 = <120,399>;
    preset Point1 = <120,20>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_h_20
  {
    preset Point2 = <219,399>;
    preset Point1 = <219,20>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_h_30
  {
    preset Point2 = <320,399>;
    preset Point1 = <320,20>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_h_40
  {
    preset Point2 = <420,399>;
    preset Point1 = <420,20>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_m_25
  {
    preset Point2 = <519,304>;
    preset Point1 = <20,304>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_m_50
  {
    preset Point2 = <519,209>;
    preset Point1 = <20,209>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object linha_m_75
  {
    preset Point2 = <519,115>;
    preset Point1 = <20,115>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object val_h_10
  {
    preset Bounds = <90,400,150,430>;
  }

  $rect <20,20,160,60>
  inherited object val_h_20
  {
    preset Bounds = <190,400,250,430>;
  }

  $rect <20,20,160,60>
  inherited object val_h_30
  {
    preset Bounds = <290,400,350,430>;
  }

  $rect <20,20,160,60>
  inherited object val_h_40
  {
    preset Bounds = <390,400,450,430>;
  }

  $rect <20,20,160,60>
  inherited object val_m_25
  {
    preset Bounds = <530,290,600,320>;
  }

  $rect <20,20,160,60>
  inherited object val_m_50
  {
    preset Bounds = <530,195,600,225>;
  }

  $rect <20,20,160,60>
  inherited object val_m_75
  {
    preset Bounds = <530,100,600,130>;
  }

  $rect <20,20,160,60>
  inherited object graf_FFT
  {
    preset Bounds = <20,20,520,400>;
    preset LineWidth = 6;
    preset CoordOrigin = <0,380>;
    preset PixelPerUnit = <10,380>;
  }

  $rect <20,20,160,60>
  inherited object borda
  {
    preset Bounds = <20,20,520,400>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object botao_R
  {
    preset Bounds = <610,60,780,130>;
  }

  $rect <20,20,160,60>
  inherited object botao_S
  {
    preset Bounds = <610,180,780,250>;
  }

  $rect <20,20,160,60>
  inherited object botao_T
  {
    preset Bounds = <610,300,780,370>;
  }
}

$rect <230,300,430,340>
$variant STM32F769
vclass PDC769 : Application::PDC
{
  $rect <0,440,140,480>
  inherited property Bounds = <0,0,800,430>;

  $rect <20,20,160,60>
  inherited object Message
  {
    preset Bounds = <10,80,790,130>;
  }

  $rect <20,20,160,60>
  inherited object BStart
  {
    preset Bounds = <120,320,360,380>;
  }

  $rect <20,20,160,60>
  inherited object labelMsg
  {
    preset Bounds = <10,10,430,60>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Estado da conexão:";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  inherited object labelState
  {
    preset Bounds = <10,170,370,220>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Estado do Servidor:";
    preset Font = Flat::FontL;
  }

  $rect <20,20,160,60>
  inherited object Status
  {
    preset Bounds = <10,220,780,280>;
    preset String = "Desconectado";
  }

  $rect <20,20,160,60>
  inherited object BStop
  {
    preset Bounds = <440,320,680,380>;
  }
}

$rect <230,690,430,730>
$output false
resource Resources::Font Arial21
{
  attr fontname FontName = Arial;
  attr fontheight Height = 21;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// Recursos para o 746.
note legend Note5
{
  attr Bounds = <30,690,230,750>;
}

// Variantes para o 769, mais a fonte para a legenda dos fasores.
note legend Note6
{
  attr Bounds = <230,730,430,810>;
}

// Icon button widget with a flat design. The widget is used as a simple push button \
// with an icon and a text item.
$rect <240,340,440,380>
$output false
class ModIconButton : Core::Group
{
  $rect <0,180,180,220>
  inherited property Bounds = <0,0,30,30>;

  $rect <0,260,180,300>
  inherited method UpdateLayout()
  {
    /* first make the super call to get the regular layouting */
    super( aSize );

    /* the arrangement of the components member depends on the height of the component */
    var int32 s = aSize.y;

    /* the button frame is always a square */
    Frame.Bounds = rect( 0, 0, s, s );

    /* the icon is lying on top of the frame */
    Image.Bounds = Frame.Bounds;
  }

  $rect <0,220,180,260>
  inherited method UpdateViewState()
  {
    /* colorize frame and text, depending on current state of the view */
    if ( aState.contains( Core::ViewState[ Enabled ]))
    {

      if ( TouchHandler.Down && TouchHandler.Inside )
        Frame.Color = ItemColorActive;
      else
        Frame.Color = ItemColor;
    }
    else
    {
      Frame.Color = Flat::ColorOfDisabled;
    }

  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,180,370,220>
  slot enterLeaveSlot
  {
    InvalidateViewState();
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <190,220,370,260>
  slot pressReleaseSlot
  {
    /* releasing the finger outside the button area is ignored */
    if ( !TouchHandler.Down && TouchHandler.Inside )
    {
      /* inform the connected slot method */
      idlesignal OnAction;
    }
  }

  // The property 'OnAction' can refer to a slot method, which will receive a signal \
  // as soon the user has pressed the button. Thereupon the method's logic will be \
  // executed.
  $rect <370,260,550,300>
  property slot OnAction = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,30>;
    preset Point3 = <30,30>;
    preset Point2 = <30,0>;
    preset Point1 = <0,0>;
    preset OnLeave = enterLeaveSlot;
    preset OnEnter = enterLeaveSlot;
    preset OnRelease = pressReleaseSlot;
    preset OnPress = pressReleaseSlot;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfTouch;
    preset Bitmap = Flat::FlatFrame;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,30,30>;
    preset Color = Flat::ColorOfBackground;
    preset FrameNumber = 19;
    preset Bitmap = Flat::FlatDemoIcons;
  }

  $rect <370,40,550,80>
  onset Icon
  {
    /* store the given value */
    pure Icon = value;

    /* assign it to the image object */
    Image.Bitmap = value;

  }

  // The property 'Icon' stores the bitmap to show in the left part of the button.
  $rect <370,0,550,40>
  property Resources::Bitmap Icon = Flat::FlatDemoIcons;

  // The property 'IconIndex' stores the frame number of the @Icon.
  $rect <370,90,550,130>
  property int32 IconIndex = 19;

  $rect <370,130,550,170>
  onset IconIndex
  {
    pure IconIndex = value;
    Image.FrameNumber = value;
  }

  // The class 'IconButton' implements a simple push button to start a certain action.
  // The button contains a text item that can be set with the property 'Caption' \
  // and it can display an icon by using the properties 'Icon' and 'IconIndex'.
  // Each time the user has pressed the button a signal is sent to the slot method \
  // 'OnAction'.
  // The colors of the widget can be changed by using the properties 'ItemColor', \
  // 'ItemColorActive', 'IconColor' and 'TextColor'.
  note legend Note
  {
    attr Bounds = <10,320,780,440>;
  }

  // The property 'BackColor' defines the background color of the widget. The property \
  // is used to assign a color independent from the current theme color.
  $rect <730,0,910,40>
  property color IconColor = Flat::ColorOfBackground;

  $rect <730,40,910,80>
  onset IconColor
  {
    /* store the new value */
    pure IconColor = value;

    /* ...and colorize the affected members of the widget */
    Image.Color = value;



  }

  // The property 'ItemColor' defines the color of the widgets touchable member (knob). \
  // The property is used to assign a color independent from the current theme color.
  $rect <550,0,730,40>
  property color ItemColor = Flat::ColorOfTouch;

  $rect <550,40,730,80>
  onset ItemColor
  {
    /* store the new value */
    pure ItemColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'TextColor' defines the color of the widgets text members. The \
  // property is used to assign a color independent from the current theme color.
  $rect <730,90,910,130>
  property color TextColor = Flat::ColorOfTouch;

  $rect <730,130,910,170>
  onset TextColor
  {
    /* store the new value */
    pure TextColor = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }

  // The property 'ItemColorActive' defines the color of the widgets touchable member \
  // (knob) while it is touched by the user. The property is used to assign a color \
  // independent from the current theme color.
  $rect <550,90,730,130>
  property color ItemColorActive = Flat::ColorOfTheme;

  $rect <550,130,730,170>
  onset ItemColorActive
  {
    /* store the new value */
    pure ItemColorActive = value;

    /* ...and finally, force an update */
    InvalidateViewState();

  }
}

$rect <40,140,210,180>
$output false
class ConfigScreen : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,380,180>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle bg
  {
    preset Bounds = <0,0,380,180>;
    preset Color = #00000080;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,380,180>;
    preset Width = 3;
  }

  $rect <20,20,160,60>
  object Views::Text labelSup
  {
    preset Bounds = <10,10,350,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Intervalo da Escala Vertical";
    preset Font = Application::NumbersM;
  }

  $rect <20,20,160,60>
  object Views::Text labelInf
  {
    preset Bounds = <10,90,370,130>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Frequência de Atualização";
    preset Font = Application::NumbersM;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton SupMenos
  {
    preset Bounds = <60,45,100,85>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 2;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton SupMais
  {
    preset Bounds = <280,45,320,85>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 3;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton InfMenos
  {
    preset Bounds = <60,125,100,165>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 2;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton InfMais
  {
    preset Bounds = <280,125,320,165>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 3;
  }

  $rect <20,20,160,60>
  object Views::Text SupVal
  {
    preset Bounds = <90,45,290,85>;
    preset String = "59 - 61 Hz";
    preset Font = Application::NumbersM;
  }

  $rect <20,20,160,60>
  object Views::Text InfVal
  {
    preset Bounds = <90,125,290,165>;
    preset String = "1 Hz (1000 ms)";
    preset Font = Application::NumbersM;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton Sair
  {
    preset Bounds = <340,0,380,40>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 9;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton SupSignMais
  {
    preset Bounds = <329,45,369,85>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 0;
  }

  $rect <20,20,160,60>
  object Application::ModIconButton SupSignMenos
  {
    preset Bounds = <11,45,51,85>;
    preset Icon = Resources::NavigationIconsMedium;
    preset IconIndex = 1;
  }
}

$rect <240,140,410,180>
$variant STM32F769
vclass ConfigScreen769 : Application::ConfigScreen
{
  $rect <10,350,150,390>
  inherited property Bounds = <0,0,600,330>;

  $rect <20,20,160,60>
  inherited object bg
  {
    preset Bounds = <0,0,600,330>;
  }

  $rect <20,20,160,60>
  inherited object Border
  {
    preset Bounds = <0,0,600,330>;
    preset Width = 6;
  }

  $rect <20,20,160,60>
  inherited object labelSup
  {
    preset Bounds = <20,20,550,70>;
  }

  $rect <20,20,160,60>
  inherited object labelInf
  {
    preset Bounds = <20,170,580,220>;
  }

  $rect <20,20,160,60>
  inherited object SupMenos
  {
    preset Bounds = <100,70,160,130>;
    preset Icon = Resources::NavigationIconsLarge;
    preset IconIndex = 2;
  }

  $rect <20,20,160,60>
  inherited object SupMais
  {
    preset Bounds = <440,70,500,130>;
    preset Icon = Resources::NavigationIconsLarge;
    preset IconIndex = 3;
  }

  $rect <20,20,160,60>
  inherited object InfMenos
  {
    preset Bounds = <100,230,160,290>;
    preset Icon = Resources::NavigationIconsLarge;
    preset IconIndex = 2;
  }

  $rect <20,20,160,60>
  inherited object InfMais
  {
    preset Bounds = <440,230,500,290>;
    preset Icon = Resources::NavigationIconsLarge;
    preset IconIndex = 3;
  }

  $rect <20,20,160,60>
  inherited object SupVal
  {
    preset Bounds = <150,70,450,130>;
    preset Font = Application::NumbersP;
  }

  $rect <20,20,160,60>
  inherited object InfVal
  {
    preset Bounds = <150,230,450,290>;
  }

  $rect <20,20,160,60>
  inherited object Sair
  {
    preset Bounds = <540,0,600,60>;
    preset Icon = Resources::KeyIconsLarge;
    preset IconIndex = 12;
  }

  $rect <20,20,160,60>
  inherited object SupSignMais
  {
    preset Bounds = <518,70,578,130>;
    preset Icon = Resources::NavigationIconsLarge;
  }

  $rect <20,20,160,60>
  inherited object SupSignMenos
  {
    preset Bounds = <22,70,82,130>;
    preset Icon = Resources::NavigationIconsLarge;
  }
}

$rect <30,380,230,420>
$output false
class PlotterGraph : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,380,180>;

  $rect <0,270,200,310>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,230,200,270>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <0,320,140,360>
  inherited method Init()
  {
    PlotterPath.Offset.x = PlotterPath.Bounds.w - 2;
    PlotterPath.Offset.y = PlotterPath.Bounds.h / 2;

    PathData.SetMaxNoOfSubPaths(1);
    PathData.InitSubPath(0, PlotterPath.Bounds.w / 2);


  }

  $rect <20,20,160,60>
  object Views::Line VLine3
  {
    preset Point2 = <285,180>;
    preset Point1 = <285,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line VLine2
  {
    preset Point2 = <190,180>;
    preset Point1 = <190,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line VLine1
  {
    preset Point2 = <95,180>;
    preset Point1 = <95,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine1
  {
    preset Point2 = <380,30>;
    preset Point1 = <0,30>;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Line HLine2
  {
    preset Point2 = <380,60>;
    preset Point1 = <0,60>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine3
  {
    preset Point2 = <380,90>;
    preset Point1 = <0,90>;
    preset Color = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Line HLine4
  {
    preset Point2 = <380,120>;
    preset Point1 = <0,120>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine5
  {
    preset Point2 = <380,150>;
    preset Point1 = <0,150>;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::StrokePath PlotterPath
  {
    preset Bounds = <0,0,380,180>;
    preset FlipY = false;
    preset Width = 2.0;
    preset Path = PathData;
  }

  $rect <390,0,590,40>
  object Graphics::Path PathData;

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,380,180>;
  }

  $rect <0,370,200,410>
  method void AddData( arg float dataPoint )
  {
    if (PlotterPath.Offset.x > 0) PlotterPath.Offset.x = PlotterPath.Offset.x - 2;

    if (PathData.GetNoOfFreeEdges(0) == 0) PathData.ShiftNodes( 0, 1, -2.0, 0.0);

    if (PathData.GetNoOfEdges(0) == 0) 
    {
      PathData.Begin(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 2.0, dataPoint);
      PathData.AddLine(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 2.0, dataPoint);
    } 
    else 
    {
      PathData.AddLine(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 2.0, dataPoint);
    }
  }

  $rect <210,190,410,230>
  property float VerticalRatio = 1.0;

  $rect <210,230,410,270>
  onset VerticalRatio
  {
    var float OldRatio = VerticalRatio;

    if (value < 1.0)
      value = 1.0;

    // The value doesn't change - nothing to do.
    if ( pure VerticalRatio == value )
      return;

    // Remember the property's new value.
    pure VerticalRatio = value;

    var float NewToOldRatio = VerticalRatio / OldRatio;

    if (PathData.GetNoOfEdges(0) > 0) {
      var int32 i;
      
      PathData.PopMatrix();
      PathData.InitMatrix();
      
      for (i = 0; i <= PathData.GetNoOfEdges(0); i = i + 1) {
        PathData.SetNode(0, i, PathData.GetNodeX(0, i), PathData.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathData.PushMatrix();
    }

    PathData.Scale(1.0, VerticalRatio);

    InvalidateViewState();
  }

  $rect <210,280,410,320>
  property color StrokeColor = #FFFFFFFF;

  $rect <210,320,410,360>
  onset StrokeColor
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeColor == value )
      return;

    // Remember the property's new value.
    pure StrokeColor = value;

    PlotterPath.Color = StrokeColor;

    InvalidateViewState();
  }

  $rect <210,370,410,410>
  property float StrokeWidth = 2.0;

  $rect <210,410,410,450>
  onset StrokeWidth
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeWidth == value )
      return;

    // Remember the property's new value.
    pure StrokeWidth = value;

    PlotterPath.Width = StrokeWidth;

    InvalidateViewState();
  }

  $rect <0,410,200,450>
  method void ClearPath()
  {
    PlotterPath.Offset.x = PlotterPath.Bounds.w - 2;
    PlotterPath.Offset.y = PlotterPath.Bounds.h / 2;

    PathData.Begin(0, 0, 0);
  }
}

$rect <30,420,230,460>
$output false
class PlotterTripleGraph : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,380,180>;

  $rect <0,270,200,310>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,230,200,270>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <0,320,140,360>
  inherited method Init()
  {
    PlotterPathR.Offset.x = PlotterPathR.Bounds.w - 2; PlotterPathS.Offset.x = PlotterPathS.Bounds.w - 2; PlotterPathT.Offset.x = PlotterPathT.Bounds.w - 2;
    PlotterPathR.Offset.y = PlotterPathR.Bounds.h / 2; PlotterPathS.Offset.y = PlotterPathS.Bounds.h / 2; PlotterPathT.Offset.y = PlotterPathT.Bounds.h / 2;

    PathDataR.SetMaxNoOfSubPaths(1); PathDataS.SetMaxNoOfSubPaths(1); PathDataS.SetMaxNoOfSubPaths(1);

    PathDataR.InitSubPath(0, PlotterPathR.Bounds.w / 2); PathDataS.InitSubPath(0, PlotterPathS.Bounds.w / 2); PathDataT.InitSubPath(0, PlotterPathT.Bounds.w / 2);
  }

  $rect <20,20,160,60>
  object Views::Line VLine3
  {
    preset Point2 = <285,180>;
    preset Point1 = <285,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line VLine2
  {
    preset Point2 = <190,180>;
    preset Point1 = <190,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line VLine1
  {
    preset Point2 = <95,180>;
    preset Point1 = <95,0>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine1
  {
    preset Point2 = <380,30>;
    preset Point1 = <0,30>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine2
  {
    preset Point2 = <380,60>;
    preset Point1 = <0,60>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine3
  {
    preset Point2 = <380,90>;
    preset Point1 = <0,90>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Line HLine4
  {
    preset Point2 = <380,120>;
    preset Point1 = <0,120>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Line HLine5
  {
    preset Point2 = <380,150>;
    preset Point1 = <0,150>;
    preset Color = #FFFFFF40;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,380,180>;
  }

  $rect <0,370,200,410>
  method void AddData( arg float dataPointR, arg float dataPointS, arg float dataPointT )
  {
    if (PlotterPathR.Offset.x > 0) PlotterPathR.Offset.x = PlotterPathR.Offset.x - 2;
    if (PlotterPathS.Offset.x > 0) PlotterPathS.Offset.x = PlotterPathS.Offset.x - 2;
    if (PlotterPathT.Offset.x > 0) PlotterPathT.Offset.x = PlotterPathT.Offset.x - 2;

    if (PathDataR.GetNoOfFreeEdges(0) == 0) PathDataR.ShiftNodes( 0, 1, -2.0, 0.0);
    if (PathDataS.GetNoOfFreeEdges(0) == 0) PathDataS.ShiftNodes( 0, 1, -2.0, 0.0);
    if (PathDataT.GetNoOfFreeEdges(0) == 0) PathDataT.ShiftNodes( 0, 1, -2.0, 0.0);

    if (PathDataR.GetNoOfEdges(0) == 0) 
    {
      PathDataR.Begin(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 2.0, dataPointR);
      PathDataR.AddLine(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 2.0, dataPointR);
    } 
    else 
    {
      PathDataR.AddLine(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 2.0, dataPointR);
    }

    if (PathDataS.GetNoOfEdges(0) == 0) 
    {
      PathDataS.Begin(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 2.0, dataPointS);
      PathDataS.AddLine(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 2.0, dataPointS);
    } 
    else 
    {
      PathDataS.AddLine(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 2.0, dataPointS);
    }

    if (PathDataT.GetNoOfEdges(0) == 0) 
    {
      PathDataT.Begin(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 2.0, dataPointT);
      PathDataT.AddLine(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 2.0, dataPointT);
    } 
    else 
    {
      PathDataT.AddLine(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 2.0, dataPointT);
    }
  }

  $rect <210,190,410,230>
  property float VerticalRatio = 1.0;

  $rect <210,230,410,270>
  onset VerticalRatio
  {
    var float OldRatio = VerticalRatio;

    if (value < 0.1)
      value = 0.1;

    // The value doesn't change - nothing to do.
    if ( pure VerticalRatio == value )
      return;

    // Remember the property's new value.
    pure VerticalRatio = value;

    var float NewToOldRatio = VerticalRatio / OldRatio;
    var int32 i;
                                        
    if (PathDataR.GetNoOfEdges(0) > 0) {
      PathDataR.PopMatrix();
      PathDataR.InitMatrix();
      
      for (i = 0; i <= PathDataR.GetNoOfEdges(0); i = i + 1) {
        PathDataR.SetNode(0, i, PathDataR.GetNodeX(0, i), PathDataR.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataR.PushMatrix();
    }

    if (PathDataS.GetNoOfEdges(0) > 0) {  
      PathDataS.PopMatrix();
      PathDataS.InitMatrix();
      
      for (i = 0; i <= PathDataS.GetNoOfEdges(0); i = i + 1) {
        PathDataS.SetNode(0, i, PathDataS.GetNodeX(0, i), PathDataS.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataS.PushMatrix();
    }

    if (PathDataT.GetNoOfEdges(0) > 0) {
      PathDataT.PopMatrix();
      PathDataT.InitMatrix();
      
      for (i = 0; i <= PathDataT.GetNoOfEdges(0); i = i + 1) {
        PathDataT.SetNode(0, i, PathDataT.GetNodeX(0, i), PathDataT.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataT.PushMatrix();
    }

    PathDataR.Scale(1.0, VerticalRatio);
    PathDataS.Scale(1.0, VerticalRatio);
    PathDataT.Scale(1.0, VerticalRatio);

    InvalidateViewState();
  }

  $rect <210,280,410,320>
  property color StrokeColorR = #FFFFFFFF;

  $rect <210,320,410,360>
  onset StrokeColorR
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeColorR == value )
      return;

    // Remember the property's new value.
    pure StrokeColorR = value;

    PlotterPathR.Color = StrokeColorR;

    InvalidateViewState();
  }

  $rect <210,370,410,410>
  property float StrokeWidth = 2.0;

  $rect <210,410,410,450>
  onset StrokeWidth
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeWidth == value )
      return;

    // Remember the property's new value.
    pure StrokeWidth = value;

    PlotterPathR.Width = StrokeWidth;
    PlotterPathS.Width = StrokeWidth;
    PlotterPathT.Width = StrokeWidth;

    InvalidateViewState();
  }

  $rect <410,280,610,320>
  property color StrokeColorS = #FFFFFFFF;

  $rect <410,320,610,360>
  onset StrokeColorS
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeColorS == value )
      return;

    // Remember the property's new value.
    pure StrokeColorS = value;

    PlotterPathS.Color = StrokeColorS;

    InvalidateViewState();
  }

  $rect <610,280,810,320>
  property color StrokeColorT = #FFFFFFFF;

  $rect <610,320,810,360>
  onset StrokeColorT
  {
    // The value doesn't change - nothing to do.
    if ( pure StrokeColorT == value )
      return;

    // Remember the property's new value.
    pure StrokeColorT = value;

    PlotterPathT.Color = StrokeColorT;

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::StrokePath PlotterPathR
  {
    preset Bounds = <0,0,380,180>;
    preset FlipY = false;
    preset Width = 2.0;
    preset Path = PathDataR;
  }

  $rect <390,0,590,40>
  object Graphics::Path PathDataR;

  $rect <20,20,160,60>
  object Views::StrokePath PlotterPathS
  {
    preset Bounds = <0,0,380,180>;
    preset FlipY = false;
    preset Width = 2.0;
    preset Path = PathDataS;
  }

  $rect <390,40,590,80>
  object Graphics::Path PathDataS;

  $rect <20,20,160,60>
  object Views::StrokePath PlotterPathT
  {
    preset Bounds = <0,0,380,180>;
    preset FlipY = false;
    preset Width = 2.0;
    preset Path = PathDataT;
  }

  $rect <390,80,590,120>
  object Graphics::Path PathDataT;

  $rect <0,410,200,450>
  method void ClearPath()
  {
    PlotterPathR.Offset.x = PlotterPathR.Bounds.w - 2; PlotterPathS.Offset.x = PlotterPathS.Bounds.w - 2; PlotterPathT.Offset.x = PlotterPathT.Bounds.w - 2;
    PlotterPathR.Offset.y = PlotterPathR.Bounds.h / 2; PlotterPathS.Offset.y = PlotterPathS.Bounds.h / 2; PlotterPathT.Offset.y = PlotterPathT.Bounds.h / 2;

    PathDataR.Begin(0, 0, 0); PathDataS.Begin(0, 0, 0); PathDataT.Begin(0, 0, 0);
  }
}

$rect <230,380,430,420>
$variant STM32F769
vclass PlotterGraph769 : Application::PlotterGraph
{
  $rect <0,340,140,380>
  inherited property Bounds = <0,0,600,330>;

  $rect <0,390,140,430>
  inherited method Init()
  {
    PlotterPath.Offset.x = PlotterPath.Bounds.w - 3;
    PlotterPath.Offset.y = PlotterPath.Bounds.h / 2;

    PathData.SetMaxNoOfSubPaths(1);
    PathData.InitSubPath(0, PlotterPath.Bounds.w / 3);


  }

  $rect <20,20,160,60>
  inherited object VLine3
  {
    preset Point2 = <449,328>;
    preset Point1 = <449,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object VLine2
  {
    preset Point2 = <299,328>;
    preset Point1 = <299,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object VLine1
  {
    preset Point2 = <150,328>;
    preset Point1 = <150,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine1
  {
    preset Point2 = <598,55>;
    preset Point1 = <0,55>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine2
  {
    preset Point2 = <598,109>;
    preset Point1 = <0,109>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine3
  {
    preset Point2 = <598,164>;
    preset Point1 = <0,164>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine4
  {
    preset Point2 = <598,219>;
    preset Point1 = <0,219>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine5
  {
    preset Point2 = <598,273>;
    preset Point1 = <0,273>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object PlotterPath
  {
    preset Bounds = <0,0,598,328>;
  }

  $rect <20,20,160,60>
  inherited object Border
  {
    preset Bounds = <0,0,600,330>;
    preset Width = 2;
  }

  $rect <160,390,300,430>
  inherited method AddData()
  {
    if (PlotterPath.Offset.x > 0) PlotterPath.Offset.x = PlotterPath.Offset.x - 3;

    if (PathData.GetNoOfFreeEdges(0) == 0) PathData.ShiftNodes( 0, 1, -3.0, 0.0);

    if (PathData.GetNoOfEdges(0) == 0) 
    {
      PathData.Begin(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 3.0, dataPoint);
      PathData.AddLine(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 3.0, dataPoint);
    } 
    else 
    {
      PathData.AddLine(0, PathData.GetNodeX(0, PathData.GetNoOfEdges(0)) + 3.0, dataPoint);
    }
  }

  $rect <0,440,190,480>
  inherited property VerticalRatio;

  $rect <0,480,190,520>
  inherited onset VerticalRatio
  {
    var float OldRatio = VerticalRatio;

    if (value < 1.0)
      value = 1.0;

    // The value doesn't change - nothing to do.
    if ( pure VerticalRatio == value )
      return;

    // Remember the property's new value.
    pure VerticalRatio = value;

    var float NewToOldRatio = VerticalRatio / OldRatio;

    if (PathData.GetNoOfEdges(0) > 0) {
      var int32 i;
      
      PathData.PopMatrix();
      PathData.InitMatrix();
      
      for (i = 0; i <= PathData.GetNoOfEdges(0); i = i + 1) {
        PathData.SetNode(0, i, PathData.GetNodeX(0, i), PathData.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathData.PushMatrix();
    }

    PathData.Scale(1.0, VerticalRatio);

    InvalidateViewState();
  }
}

$rect <230,420,430,460>
$variant STM32F769
vclass PlotterTripleGraph769 : Application::PlotterTripleGraph
{
  $rect <10,360,150,400>
  inherited property Bounds = <0,0,600,330>;

  $rect <230,400,370,440>
  inherited method Init()
  {
    PlotterPathR.Offset.x = PlotterPathR.Bounds.w - 3; PlotterPathS.Offset.x = PlotterPathS.Bounds.w - 3; PlotterPathT.Offset.x = PlotterPathT.Bounds.w - 3;
    PlotterPathR.Offset.y = PlotterPathR.Bounds.h / 2; PlotterPathS.Offset.y = PlotterPathS.Bounds.h / 2; PlotterPathT.Offset.y = PlotterPathT.Bounds.h / 2;

    PathDataR.SetMaxNoOfSubPaths(1); PathDataS.SetMaxNoOfSubPaths(1); PathDataS.SetMaxNoOfSubPaths(1);

    PathDataR.InitSubPath(0, PlotterPathR.Bounds.w / 3); PathDataS.InitSubPath(0, PlotterPathS.Bounds.w / 3); PathDataT.InitSubPath(0, PlotterPathT.Bounds.w / 3);

  }

  $rect <20,20,160,60>
  inherited object VLine3
  {
    preset Point2 = <449,328>;
    preset Point1 = <449,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object VLine2
  {
    preset Point2 = <299,328>;
    preset Point1 = <299,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object VLine1
  {
    preset Point2 = <150,328>;
    preset Point1 = <150,0>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine1
  {
    preset Point2 = <598,55>;
    preset Point1 = <0,55>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine2
  {
    preset Point2 = <598,109>;
    preset Point1 = <0,109>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine3
  {
    preset Point2 = <598,164>;
    preset Point1 = <0,164>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine4
  {
    preset Point2 = <598,219>;
    preset Point1 = <0,219>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object HLine5
  {
    preset Point2 = <598,273>;
    preset Point1 = <0,273>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  inherited object Border
  {
    preset Bounds = <0,0,598,328>;
    preset Width = 2;
  }

  $rect <230,360,370,400>
  inherited method AddData()
  {
    if (PlotterPathR.Offset.x > 0) PlotterPathR.Offset.x = PlotterPathR.Offset.x - 3;
    if (PlotterPathS.Offset.x > 0) PlotterPathS.Offset.x = PlotterPathS.Offset.x - 3;
    if (PlotterPathT.Offset.x > 0) PlotterPathT.Offset.x = PlotterPathT.Offset.x - 3;

    if (PathDataR.GetNoOfFreeEdges(0) == 0) PathDataR.ShiftNodes( 0, 1, -3.0, 0.0);
    if (PathDataS.GetNoOfFreeEdges(0) == 0) PathDataS.ShiftNodes( 0, 1, -3.0, 0.0);
    if (PathDataT.GetNoOfFreeEdges(0) == 0) PathDataT.ShiftNodes( 0, 1, -3.0, 0.0);

    if (PathDataR.GetNoOfEdges(0) == 0) 
    {
      PathDataR.Begin(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 3.0, dataPointR);
      PathDataR.AddLine(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 3.0, dataPointR);
    } 
    else 
    {
      PathDataR.AddLine(0, PathDataR.GetNodeX(0, PathDataR.GetNoOfEdges(0)) + 3.0, dataPointR);
    }

    if (PathDataS.GetNoOfEdges(0) == 0) 
    {
      PathDataS.Begin(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 3.0, dataPointS);
      PathDataS.AddLine(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 3.0, dataPointS);
    } 
    else 
    {
      PathDataS.AddLine(0, PathDataS.GetNodeX(0, PathDataS.GetNoOfEdges(0)) + 3.0, dataPointS);
    }

    if (PathDataT.GetNoOfEdges(0) == 0) 
    {
      PathDataT.Begin(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 3.0, dataPointT);
      PathDataT.AddLine(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 3.0, dataPointT);
    } 
    else 
    {
      PathDataT.AddLine(0, PathDataT.GetNodeX(0, PathDataT.GetNoOfEdges(0)) + 3.0, dataPointT);
    }
  }

  $rect <10,400,150,440>
  inherited property VerticalRatio;

  $rect <10,440,220,480>
  inherited onset VerticalRatio
  {
    var float OldRatio = VerticalRatio;

    if (value < 0.1)
      value = 0.1;

    // The value doesn't change - nothing to do.
    if ( pure VerticalRatio == value )
      return;

    // Remember the property's new value.
    pure VerticalRatio = value;

    var float NewToOldRatio = VerticalRatio / OldRatio;
    var int32 i;
                                        
    if (PathDataR.GetNoOfEdges(0) > 0) {
      PathDataR.PopMatrix();
      PathDataR.InitMatrix();
      
      for (i = 0; i <= PathDataR.GetNoOfEdges(0); i = i + 1) {
        PathDataR.SetNode(0, i, PathDataR.GetNodeX(0, i), PathDataR.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataR.PushMatrix();
    }

    if (PathDataS.GetNoOfEdges(0) > 0) {  
      PathDataS.PopMatrix();
      PathDataS.InitMatrix();
      
      for (i = 0; i <= PathDataS.GetNoOfEdges(0); i = i + 1) {
        PathDataS.SetNode(0, i, PathDataS.GetNodeX(0, i), PathDataS.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataS.PushMatrix();
    }

    if (PathDataT.GetNoOfEdges(0) > 0) {
      PathDataT.PopMatrix();
      PathDataT.InitMatrix();
      
      for (i = 0; i <= PathDataT.GetNoOfEdges(0); i = i + 1) {
        PathDataT.SetNode(0, i, PathDataT.GetNodeX(0, i), PathDataT.GetNodeY(0, i) * NewToOldRatio);
      }
      
      PathDataT.PushMatrix();
    }

    PathDataR.Scale(1.0, VerticalRatio);
    PathDataS.Scale(1.0, VerticalRatio);
    PathDataT.Scale(1.0, VerticalRatio);

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  inherited object PlotterPathR
  {
    preset Bounds = <0,0,598,328>;
  }

  $rect <20,20,160,60>
  inherited object PlotterPathS
  {
    preset Bounds = <0,0,598,328>;
  }

  $rect <20,20,160,60>
  inherited object PlotterPathT
  {
    preset Bounds = <0,0,598,328>;
  }
}

$rect <650,270,850,310>
$output false
class PDCButtonState
{
  $rect <10,10,210,50>
  property bool Iniciar = true;

  $rect <10,50,210,90>
  onset Iniciar
  {
    // The value doesn't change - nothing to do.
    if ( pure Iniciar == value )
      return;

    // Remember the property's new value.
    pure Iniciar = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <10,90,210,130>
  onget Iniciar
  {
    return pure Iniciar;
  }

  $rect <210,10,410,50>
  property bool Parar = false;

  $rect <210,50,410,90>
  onset Parar
  {
    // The value doesn't change - nothing to do.
    if ( pure Parar == value )
      return;

    // Remember the property's new value.
    pure Parar = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <210,90,410,130>
  onget Parar
  {
    return pure Parar;
  }
}
