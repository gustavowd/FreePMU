/*******************************************************************************
*
* E M B E D D E D   W I Z A R D   P R O J E C T
*
*                                                Copyright (c) TARA Systems GmbH
*                                    written by Paul Banach and Manfred Schweyer
*
********************************************************************************
*
* This file was generated automatically by Embedded Wizard Studio.
*
* Please do not make any modifications of this file! The modifications are lost
* when the file is generated again by Embedded Wizard Studio!
*
* The template of this heading text can be found in the file 'head.ewt' in the
* directory 'Platforms' of your Embedded Wizard installation directory. If you
* wish to adapt this text, please copy the template file 'head.ewt' into your
* project directory and edit the copy only. Please avoid any modifications of
* the original template file!
*
* Version  : 9.00
* Profile  : STM32F746
* Platform : STM.STM32.RGB565
*
*******************************************************************************/

#ifndef _CoreSystemEvent_H
#define _CoreSystemEvent_H

#ifdef __cplusplus
  extern "C"
  {
#endif

#include "ewrte.h"
#if EW_RTE_VERSION != 0x00090000
  #error Wrong version of Embedded Wizard Runtime Environment.
#endif

#include "ewgfx.h"
#if EW_GFX_VERSION != 0x00090000
  #error Wrong version of Embedded Wizard Graphics Engine.
#endif

/* Forward declaration of the class Core::SystemEvent */
#ifndef _CoreSystemEvent_
  EW_DECLARE_CLASS( CoreSystemEvent )
#define _CoreSystemEvent_
#endif

/* Forward declaration of the class Core::TaskQueue */
#ifndef _CoreTaskQueue_
  EW_DECLARE_CLASS( CoreTaskQueue )
#define _CoreTaskQueue_
#endif


/* The class Core::SystemEvent provides a convenient component intended to represent 
   a source of an individual system event. Such events are usually generated by 
   the real device the GUI application is designed for. Here for example, the device 
   can report the current status of an engine every time this engine starts or stops.
   Sophisticated mechanisms behind Core::SystemEvent take care of the delivery of 
   all events to associated handler components (see Core::SystemEventHandler). The 
   delivery succeeds asynchronously however always accordingly to the order in which 
   the events were triggered.
   To trigger an event simply call the method @Trigger(). Each time you trigger 
   an event, you can optionally provide a context object to be dispatched together 
   with the event. In this manner flexible application cases are possible.
   Usually you create and maintain system event instances globally, e.g. within 
   a device autoobject. Once a system event instance is available, you can connect 
   one or more system event handlers with it. */
EW_DEFINE_FIELDS( CoreSystemEvent, XObject )
  EW_VARIABLE( context,         XObject )
  EW_VARIABLE( queue,           CoreTaskQueue )
EW_END_OF_FIELDS( CoreSystemEvent )

/* Virtual Method Table (VMT) for the class : 'Core::SystemEvent' */
EW_DEFINE_METHODS( CoreSystemEvent, XObject )
EW_END_OF_METHODS( CoreSystemEvent )

/* The method Trigger() enqueues this event for delivery. The delivery occurs asynchronously 
   in the order in which the events are triggered. If the parameter aWithPriority 
   is false, the new event will be arranged at the end of a common system event 
   queue. If the parameter is true, the event is enqueued in front of all waiting 
   events causing it to be delivered early.
   When the event is delivered all associated Core::SystemEventHandler components 
   are notified to handle the event. Here the system event handler can access and 
   evaluate the optional context data passed in the parameter aContext. */
void CoreSystemEvent_Trigger( CoreSystemEvent _this, XObject aContext, XBool aWithPriority );

#ifdef __cplusplus
  }
#endif

#endif /* _CoreSystemEvent_H */

/* Embedded Wizard */
